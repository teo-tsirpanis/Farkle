<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Quick Start: Creating a calculator
</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Theodore Tsirpanis">
  <meta name="description" content="Farkle - Quick Start: Creating a calculator
">

  <link rel="stylesheet" id="theme_link" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.6.0/materia/bootstrap.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" integrity="sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF" crossorigin="anonymous"></script>

  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/navbar-fixed-left.css" />
  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-default.css" />
  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-custom.css" />
  <style>
    .container img {
      max-height: 100%;
      max-width: 100%;
    }
  </style>
  <script async type="text/javascript" src="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-tips.js"></script>
  <!-- BEGIN SEARCH BOX: this adds support for the search box -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
  <!-- END SEARCH BOX: this adds support for the search box -->
</head>

  <body>
    <nav class="navbar navbar-expand-md navbar-light bg-secondary fixed-left" id="fsdocs-nav">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <a href="https://teo-tsirpanis.github.io/Farkle/index.html"><img id="fsdocs-logo" src="https://teo-tsirpanis.github.io/Farkle/img/logo.png" /></a>
        <!-- BEGIN SEARCH BOX: this adds support for the search box -->
        <div id="header">
          <div class="searchbox" id="fsdocs-searchbox">
            <input data-search-input="" id="search-by" type="search" placeholder="Search..." />
          </div>
        </div>
        <!-- END SEARCH BOX: this adds support for the search box -->

        <ul class="navbar-nav">
          <li class="nav-header">Links</li>
          <li class="nav-item"><a class="nav-link" href="https://nuget.org/packages/Farkle">Get Library via NuGet</a></li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/teo-tsirpanis/Farkle">Source Code on GitHub</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/license.html">License</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/release-notes.html">Release Notes</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/choosing-a-parser.html">Choosing a parser: Farkle vs alternatives</a></li>

          <li class="nav-header">Getting started</li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/quickstart.html">Quick Start with F#</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/csharp.html">Using Farkle with C#</a></li>

          <li class="nav-header">Documentation</li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/reference/index.html">API Reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/templates.html">Templating Reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/string-regexes.html">String regex reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/the-precompiler.html">The precompiler</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/advanced-features.html">Advanced Features</a></li>
        </ul>
      </div>
    </nav>
    <div class="container">
        <div class="masthead">
            <h3 class="muted"><a href="https://teo-tsirpanis.github.io/Farkle/index.html">Farkle</a></h3>
        </div>
        <hr />
        <div class="container" id="fsdocs-content">
            <h1><a name="Quick-Start-Creating-a-calculator" class="anchor" href="#Quick-Start-Creating-a-calculator">Quick Start: Creating a calculator</a></h1>
<p>Hello everyone. This guide will help you use Farkle. We will be using F#, but during the process, you will learn some useful things about Farkle itself. There's <a href="csharp.html">another guide that explains what's different with C#</a>. Familiarity with context-free grammars and parsing will be very helpful.</p>
<h2><a name="How-Farkle-works" class="anchor" href="#How-Farkle-works">How Farkle works</a></h2>
<p>While parser combinator libraries like FParsec combine many small parsers into a big parser, Farkle combines simple <em>grammars</em> (i.e. descriptions of languages) into more complex ones, and has a single, multi-purpose parser. These composable grammars are called <em>designtime Farkles</em> and implement the <code>Farkle.Builder.DesigntimeFarkle</code> interface.</p>
<p>Also, as with FParsec, a designtime Farkle can "return" something. In this case it also implements the <code>DesigntimeFarkle&lt;TResult&gt;</code> interface. For our calculator, our designtime Farkles will return a number, which is the numerical result of our mathematical expression.</p>
<blockquote>
<p><strong>Warning:</strong> Despite designtime Farkles being interfaces, implementing it in your code is not allowed and will throw an exception if a custom designtime Farkle implementation is somehow passed to Farkle.</p>
</blockquote>
<p>To be able to use a designtime Farkle, we will first give it to a component called the <em>builder</em>. The builder will check the grammar for errors, create the necessary structures for the parser, and give us another special object called a <em>runtime Farkle</em>. With a runtime Farkle, we can parse text to our heart's desires, but in contrast with a designtime Farkle, we cannot compose it.</p>
<p>10: By the way, Farkle means "FArkle Recognizes Known Languages Easily".</p>
<p>20: And "FArkle" means (GOTO 10).</p>
<p>30: I guess you can't read this line.</p>
<h2><a name="Designing-our-grammar" class="anchor" href="#Designing-our-grammar">Designing our grammar</a></h2>
<p>We want to design a grammar that represents mathematical expressions on floating-point numbers. The supported operations will be addition, subtraction, multiplication, division, and unary negation. The operator precedence has to be honored, as well as parentheses.</p>
<p>A similar grammar but on the integers, can be found <a href="https://github.com/teo-tsirpanis/Farkle/blob/2ecc66d6b7b43a1b52b889aec78e865c0c5cf325/sample/Farkle.JSON.FSharp/SimpleMaths.fs#L68">here</a></p>
<p>For those that don't know, a context-free grammar is made of <em>terminals</em>, <em>nonterminals</em> and <em>productions</em>.</p>
<ul>
<li>Terminals are elementary symbols that correspond to characters from our source text.</li>
</ul>
<p>*
Nonterminals are composite symbols made of terminals and other nonterminals.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">One</span> <span class="k">of</span> <span class="id">the</span> <span class="id">nonterminals</span> <span class="id">is</span> <span class="id">designated</span> <span class="k">as</span> <span class="id">the</span> <span class="id">_start</span> <span class="id">symbol_</span><span class="pn">,</span> <span class="k">and</span> <span class="id">it</span> <span class="id">is</span> <span class="id">the</span> <span class="id">nonterminal</span> <span class="id">from</span> <span class="id">which</span> <span class="id">parsing</span> <span class="id">will</span> <span class="id">start</span><span class="pn">.</span>
</code></pre>
<ul>
<li>Productions are the rules that define what symbols can be placed inside a nonterminal, and at which order.</li>
</ul>
<h3><a name="The-terminals" class="anchor" href="#The-terminals">The terminals</a></h3>
<p>We don't have to explicitly write a terminal for the mathematical symbols. They are just symbols that can have only one value and do not contain any meaningful information other than their presence. Farkle calls these types of symbols <em>literals</em> and treats them specially to reduce boilerplate.</p>
<p>So we are now left with one terminal to define; the terminal for our decimal numbers. In Farkle, terminals are made of a regular expression that specifies the text that can match to this terminal, and a delegate called <em>transformer</em> that converts the text to an arbitrary object.</p>
<p>There are three ways to create this terminal, starting from the simplest:</p>
<hr />
<p>The <code>Farkle.Builder.Terminals</code> has functions that allow you to create some commonly needed terminals, like integers or floating-point numbers. We create our terminal this way:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">Farkle</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 2)" onmouseover="showTip(event, 'fs1', 2)" class="id">Farkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 3)" onmouseover="showTip(event, 'fs2', 3)" class="id">Builder</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs3', 4)" onmouseover="showTip(event, 'fs3', 4)" class="id">System</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs4', 5)" onmouseover="showTip(event, 'fs4', 5)" class="id">number</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 6)" onmouseover="showTip(event, 'fs5', 6)" class="m">Terminals</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="id">genericReal</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs7', 8)" onmouseover="showTip(event, 'fs7', 8)" class="vt">float</span><span class="pn">&gt;</span> <span class="k">false</span> <span class="s">&quot;Number&quot;</span>
</code></pre>
<p>The boolean parameter specifies whether to allow a minus sign at the beginning (we don't). The last parameter is the terminal's name, used for error reporting.</p>
<p>The <code>Terminals</code> module has more functions. You can see them all <a href="reference/farkle-builder-terminals.html">in the documentation</a>.</p>
<hr />
<p>If Farkle doesn't have a ready to use function for your terminal, we have to create the terminal ourselves. The most easy way to do it is to write a regex using a string:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 9)" onmouseover="showTip(event, 'fs8', 9)" class="id">numberStringRegex</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="m">Regex</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 11)" onmouseover="showTip(event, 'fs10', 11)" class="id">regexString</span> <span class="s">@&quot;\d+(\.\d+)?(e[+-]?\d+)?&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="fn">terminal</span> <span class="s">&quot;Number&quot;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="fn">T</span><span class="pn">(</span><span class="k">fun</span> <span class="id">_</span> <span onmouseout="hideTip(event, 'fs13', 14)" onmouseover="showTip(event, 'fs13', 14)" class="fn">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 15)" onmouseover="showTip(event, 'fs7', 15)" class="fn">float</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="fn">x</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="id">ToString</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>The <code>regexString</code> function uses a quite familiar regex syntax. You can learn more about it <a href="string-regexes.html">at its own documentation page</a>.</p>
<p>Let's take a look at the <code>terminal</code> function. Its last parameter is the regex, which we passed at the beggining for convenience and its first parameter is the terminal's name; nothing unusual here. Its second parameter is called a <em>transformer</em> and is a delegate that converts the characters matched by our regex to an arbitrary object; in our case an integer.</p>
<h4><a name="Writing-a-transformer" class="anchor" href="#Writing-a-transformer">Writing a transformer</a></h4>
<p>The transformer's first parameter is an object of type <a href="reference/farkle-itransformercontext.html"><code>ITransformerContext</code></a> and is useful if you want to access the token's position or share some state between transformers, and its second parameter is a <code>ReadOnlySpan</code> of the characters matched by our regex, which will be converted to a floating-point number by our transformer.</p>
<p><code>T</code> is the delegate's F# name. Because you have to specify it due to the language's limitations it was shortened to one letter for brevity.</p>
<p>You can view transformers as little parsers that always parse well-formatted text. In our example, the transformer for <code>Number</code> does not usually have to worry about exceptions from invalid input since the regex we specified guarantees the kind of input it expects. There are exceptions to this, like the user passing an extremely high integer. Such inputs will cause an exception to be raised. The built-in terminals the <code>Farkle.Builder.Terminals</code> module provides will handle the exception a little more gracefully but still fail the parsing.</p>
<p>Speaking of graceful errors, you can raise errors in your transformer by calling the <code>error</code> function, or the <code>errorf</code> function if you want formatted strings. If you are using C# or want to customize the exact position of the error, you can directly throw a <code>Farkle.ParserApplicationException</code>. They will be caught by the parser and can be uniformly handled like Farkle's own errors, as we will see later.</p>
<hr />
<p>For the most advanced use cases, Farkle allows you to construct a regex from code. Directly constructing a regex from code is rarely useful for the average user of Farkle, but might come in handy when for example the regex's structure is not known at compile time, or it is complex enough to merit some code reuse.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 18)" onmouseover="showTip(event, 'fs1', 18)" class="id">Farkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 19)" onmouseover="showTip(event, 'fs2', 19)" class="id">Builder</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs9', 20)" onmouseover="showTip(event, 'fs9', 20)" class="m">Regex</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 21)" onmouseover="showTip(event, 'fs15', 21)" class="id">numberConstructedRegex</span> <span class="o">=</span>
    <span class="c">// Regexes are composable!</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 22)" onmouseover="showTip(event, 'fs16', 22)" class="fn">atLeastOneNumber</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 23)" onmouseover="showTip(event, 'fs17', 23)" class="fn">chars</span> <span onmouseout="hideTip(event, 'fs18', 24)" onmouseover="showTip(event, 'fs18', 24)" class="m">PredefinedSets</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs19', 25)" onmouseover="showTip(event, 'fs19', 25)" class="id">Number</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs20', 26)" onmouseover="showTip(event, 'fs20', 26)" class="fn">atLeast</span> <span class="n">1</span>
    <span class="c">// You can freely mix string regexes and constructed regexes.</span>
    <span class="c">// let atLeastOneNumber = regexString @&quot;\d+&quot;</span>
    <span onmouseout="hideTip(event, 'fs21', 27)" onmouseover="showTip(event, 'fs21', 27)" class="fn">concat</span> <span class="pn">[</span>
        <span onmouseout="hideTip(event, 'fs16', 28)" onmouseover="showTip(event, 'fs16', 28)" class="fn">atLeastOneNumber</span>
        <span onmouseout="hideTip(event, 'fs22', 29)" onmouseover="showTip(event, 'fs22', 29)" class="fn">optional</span> <span class="o">&lt;|</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 30)" onmouseover="showTip(event, 'fs23', 30)" class="fn">char</span> <span class="s">&#39;.&#39;</span> <span class="o">&lt;&amp;&gt;</span> <span onmouseout="hideTip(event, 'fs16', 31)" onmouseover="showTip(event, 'fs16', 31)" class="fn">atLeastOneNumber</span><span class="pn">)</span>
        <span class="pn">[</span><span onmouseout="hideTip(event, 'fs17', 32)" onmouseover="showTip(event, 'fs17', 32)" class="fn">chars</span> <span class="s">&quot;eE&quot;</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs17', 33)" onmouseover="showTip(event, 'fs17', 33)" class="fn">chars</span> <span class="s">&quot;+-&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 34)" onmouseover="showTip(event, 'fs22', 34)" class="fn">optional</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs16', 35)" onmouseover="showTip(event, 'fs16', 35)" class="fn">atLeastOneNumber</span><span class="pn">]</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 36)" onmouseover="showTip(event, 'fs21', 36)" class="fn">concat</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 37)" onmouseover="showTip(event, 'fs22', 37)" class="fn">optional</span>
    <span class="pn">]</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs11', 38)" onmouseover="showTip(event, 'fs11', 38)" class="fn">terminal</span> <span class="s">&quot;Number&quot;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs12', 39)" onmouseover="showTip(event, 'fs12', 39)" class="fn">T</span><span class="pn">(</span><span class="k">fun</span> <span class="id">_</span> <span onmouseout="hideTip(event, 'fs13', 40)" onmouseover="showTip(event, 'fs13', 40)" class="fn">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 41)" onmouseover="showTip(event, 'fs7', 41)" class="fn">float</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs13', 42)" onmouseover="showTip(event, 'fs13', 42)" class="fn">x</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs14', 43)" onmouseover="showTip(event, 'fs14', 43)" class="id">ToString</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>You can learn more about the functions above <a href="reference/farkle-builder-regexmodule.html">at the documentation</a>. More character sets of the <code>Farkle.Builder.PredefinedSets</code> module can also be found <a href="reference/farkle-builder-predefinedsets.html">at the documentation</a></p>
<blockquote>
<p><strong>Note:</strong> The regexes' type is <code>Farkle.Builder.Regex</code>. They are totally unrelated to .NET's <code>System.Text.RegularExpressions.Regex</code>. We can't convert between these two types, or directly match text against Farkle's regexes.</p>
</blockquote>
<p>The terminal we created is of type <code>DesigntimeFarkle&lt;float&gt;</code>. This means that we can use it to parse floating-point numbers from text, but we want to create something bigger than that. As we are going to see, we can compose designtime Farkles into bigger ones, using nonterminals.</p>
<h2><a name="The-nonterminals" class="anchor" href="#The-nonterminals">The nonterminals.</a></h2>
<h3><a name="Writing-simple-nonterminals" class="anchor" href="#Writing-simple-nonterminals">Writing simple nonterminals.</a></h3>
<p>Because the calculator's nonterminals are a bit complicated, we have to take a brief interlude and tell how to create simpler ones.</p>
<p>Say we want to make a very simple calculator that can either add or subtract two numbers together. And let's say that an empty string would result to zero. This is the grammar of our calculator in <a href="https://en.wikipedia.org/wiki/Backus-Naur_form">Backus-Naur Form</a>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">&lt;</span><span class="id">Exp</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="id">Number</span> <span class="o">+</span> <span class="id">Number</span>
<span class="pn">&lt;</span><span class="id">Exp</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="id">Number</span> <span class="o">-</span> <span class="id">Number</span>
<span class="pn">&lt;</span><span class="id">Exp</span><span class="pn">&gt;</span> <span class="o">::</span><span class="o">=</span> <span class="o">&lt;&gt;</span>
</code></pre>
<p>For those that don't understand the snippet above, we define a nonterminal named <code>Exp</code>, that has three productions associated with it, meaning an <code>Exp</code> can be made in three ways: either by taking a sequence of the <code>Number</code> terminal, either the <code>+</code> or the <code>-</code> terminal, and another <code>Number</code> terminal, or by no symbols at all.</p>
<p>Writing the same thing in Farkle is actually surprisingly simple:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 44)" onmouseover="showTip(event, 'fs24', 44)" class="id">justTwoNumbers</span> <span class="o">=</span> <span class="s">&quot;Exp&quot;</span> <span class="o">||=</span> <span class="pn">[</span>
    <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs4', 45)" onmouseover="showTip(event, 'fs4', 45)" class="id">number</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;+&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs4', 46)" onmouseover="showTip(event, 'fs4', 46)" class="id">number</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 47)" onmouseover="showTip(event, 'fs25', 47)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 48)" onmouseover="showTip(event, 'fs26', 48)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 49)" onmouseover="showTip(event, 'fs25', 49)" class="fn">x1</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs26', 50)" onmouseover="showTip(event, 'fs26', 50)" class="fn">x2</span><span class="pn">)</span>
    <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs4', 51)" onmouseover="showTip(event, 'fs4', 51)" class="id">number</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;-&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs4', 52)" onmouseover="showTip(event, 'fs4', 52)" class="id">number</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 53)" onmouseover="showTip(event, 'fs25', 53)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 54)" onmouseover="showTip(event, 'fs26', 54)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 55)" onmouseover="showTip(event, 'fs25', 55)" class="fn">x1</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs26', 56)" onmouseover="showTip(event, 'fs26', 56)" class="fn">x2</span><span class="pn">)</span>
    <span onmouseout="hideTip(event, 'fs27', 57)" onmouseover="showTip(event, 'fs27', 57)" class="id">empty</span> <span class="o">=%</span> <span class="n">0.0</span>
<span class="pn">]</span>
</code></pre>
<p>Let's explain what was going here. With the <code>||=</code> operator, we define a nonterminal with its productions. In its left side goes its name, and in its right side go the productions that can produce it.</p>
<p>See these strange symbols inside the list? They chain designtime Farkles together and signify which of them have information we care about. <code>!@</code> starts defining a production with its first member carrying significant information (the first operand). To start a production with a designtime Farkle that does not carry significant information, we can use <code>!%</code>.</p>
<p>The <code>.&gt;&gt;</code> and <code>.&gt;&gt;.</code> operators resemble FParsec's ones. <code>.&gt;&gt;</code> chains a new designtime Farkle we don't care what contains, and <code>.&gt;&gt;.</code> chains one we do.</p>
<p>With <code>.&gt;&gt;</code>, we can also chain string literals, instead of creating a terminal for each. We can also start a production with a literal using the <code>!&amp;</code> operator.</p>
<p>The <code>=&gt;</code> operator finishes the creation of a production with a function that combines its members that we marked as significant. Such functions are called <em>fusers</em>. In the first production we added the numbers and in the second we subtracted them. So, depending on the expression we entered, <code>_justTwoNumbers</code> would return either the sum, or the difference of them. Obviously, all productions of a nonterminal have to return the same type.</p>
<p>In the third case, we defined an empty production using <code>empty</code> (what a coincidence!) We used <code>empty =% 0.0</code> as a shortcut instead of writing <code>empty =&gt; (fun () -&gt; 0.0)</code>.</p>
<p>An unfinished production is called a <em>production builder</em>. You can mark up to 16 significant members in a production builder.</p>
<p>You can pass an empty list in the right hand of the <code>||=</code> operator but the grammar will be invalid. A nonterminal must always have at least one production.</p>
<h3><a name="Writing-more-complex-nonterminals" class="anchor" href="#Writing-more-complex-nonterminals">Writing more complex nonterminals</a></h3>
<p>We want our calculator to implement the following grammar <a href="https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html">taken from Bison's documentation</a>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="o">%</span><span class="id">left</span> <span class="s">&#39;-&#39;</span> <span class="s">&#39;+&#39;</span>
<span class="o">%</span><span class="id">left</span> <span class="s">&#39;*&#39;</span> <span class="s">&#39;/&#39;</span>
<span class="o">%</span><span class="id">precedence</span> <span class="id">NEG</span>
<span class="o">%</span><span class="id">right</span> <span class="s">&#39;^&#39;</span>

<span onmouseout="hideTip(event, 'fs28', 58)" onmouseover="showTip(event, 'fs28', 58)" class="id">exp</span><span class="pn">:</span>
    <span class="id">NUM</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs28', 59)" onmouseover="showTip(event, 'fs28', 59)" class="id">exp</span> <span class="s">&#39;+&#39;</span> <span onmouseout="hideTip(event, 'fs28', 60)" onmouseover="showTip(event, 'fs28', 60)" class="id">exp</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">$</span><span class="n">1</span> <span class="o">+</span> <span class="o">$</span><span class="n">3</span><span class="pn">;</span>      <span class="pn">}</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs28', 61)" onmouseover="showTip(event, 'fs28', 61)" class="id">exp</span> <span class="s">&#39;-&#39;</span> <span onmouseout="hideTip(event, 'fs28', 62)" onmouseover="showTip(event, 'fs28', 62)" class="id">exp</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">$</span><span class="n">1</span> <span class="o">-</span> <span class="o">$</span><span class="n">3</span><span class="pn">;</span>      <span class="pn">}</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs28', 63)" onmouseover="showTip(event, 'fs28', 63)" class="id">exp</span> <span class="s">&#39;*&#39;</span> <span onmouseout="hideTip(event, 'fs28', 64)" onmouseover="showTip(event, 'fs28', 64)" class="id">exp</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">$</span><span class="n">1</span> <span class="pn">*</span> <span class="o">$</span><span class="n">3</span><span class="pn">;</span>      <span class="pn">}</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs28', 65)" onmouseover="showTip(event, 'fs28', 65)" class="id">exp</span> <span class="s">&#39;/&#39;</span> <span onmouseout="hideTip(event, 'fs28', 66)" onmouseover="showTip(event, 'fs28', 66)" class="id">exp</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">$</span><span class="n">1</span> <span class="o">/</span> <span class="o">$</span><span class="n">3</span><span class="pn">;</span>      <span class="pn">}</span>
    <span class="pn">|</span> <span class="s">&#39;-&#39;</span> <span onmouseout="hideTip(event, 'fs28', 67)" onmouseover="showTip(event, 'fs28', 67)" class="id">exp</span>  <span class="o">%</span><span class="id">prec</span> <span class="id">NEG</span> <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">-$</span><span class="n">2</span><span class="pn">;</span>          <span class="pn">}</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs28', 68)" onmouseover="showTip(event, 'fs28', 68)" class="id">exp</span> <span class="s">&#39;^&#39;</span> <span onmouseout="hideTip(event, 'fs28', 69)" onmouseover="showTip(event, 'fs28', 69)" class="id">exp</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="id">pow</span> <span class="pn">(</span><span class="o">$</span><span class="n">1</span><span class="pn">,</span> <span class="o">$</span><span class="n">3</span><span class="pn">)</span><span class="pn">;</span> <span class="pn">}</span>
    <span class="pn">|</span> <span class="s">&#39;(&#39;</span> <span onmouseout="hideTip(event, 'fs28', 70)" onmouseover="showTip(event, 'fs28', 70)" class="id">exp</span> <span class="s">&#39;)&#39;</span>        <span class="pn">{</span> <span class="o">$$</span> <span class="o">=</span> <span class="o">$</span><span class="n">2</span><span class="pn">;</span>           <span class="pn">}</span>
<span class="pn">;</span>
</code></pre>
<p>And this is how to implement it in Farkle:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 71)" onmouseover="showTip(event, 'fs1', 71)" class="id">Farkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 72)" onmouseover="showTip(event, 'fs2', 72)" class="id">Builder</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs29', 73)" onmouseover="showTip(event, 'fs29', 73)" class="id">OperatorPrecedence</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 74)" onmouseover="showTip(event, 'fs30', 74)" class="id">expression</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs31', 75)" onmouseover="showTip(event, 'fs31', 75)" class="fn">NEG</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs32', 76)" onmouseover="showTip(event, 'fs32', 76)" class="fn">obj</span><span class="pn">(</span><span class="pn">)</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 77)" onmouseover="showTip(event, 'fs30', 77)" class="fn">expression</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 78)" onmouseover="showTip(event, 'fs33', 78)" class="fn">nonterminal</span> <span class="s">&quot;Expression&quot;</span>
    <span onmouseout="hideTip(event, 'fs30', 79)" onmouseover="showTip(event, 'fs30', 79)" class="fn">expression</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs34', 80)" onmouseover="showTip(event, 'fs34', 80)" class="id">SetProductions</span><span class="pn">(</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs4', 81)" onmouseover="showTip(event, 'fs4', 81)" class="id">number</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs35', 82)" onmouseover="showTip(event, 'fs35', 82)" class="fn">asIs</span><span class="pn">,</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs30', 83)" onmouseover="showTip(event, 'fs30', 83)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;+&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 84)" onmouseover="showTip(event, 'fs30', 84)" class="fn">expression</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 85)" onmouseover="showTip(event, 'fs25', 85)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 86)" onmouseover="showTip(event, 'fs26', 86)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 87)" onmouseover="showTip(event, 'fs25', 87)" class="fn">x1</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs26', 88)" onmouseover="showTip(event, 'fs26', 88)" class="fn">x2</span><span class="pn">)</span><span class="pn">,</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs30', 89)" onmouseover="showTip(event, 'fs30', 89)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;-&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 90)" onmouseover="showTip(event, 'fs30', 90)" class="fn">expression</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 91)" onmouseover="showTip(event, 'fs25', 91)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 92)" onmouseover="showTip(event, 'fs26', 92)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 93)" onmouseover="showTip(event, 'fs25', 93)" class="fn">x1</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs26', 94)" onmouseover="showTip(event, 'fs26', 94)" class="fn">x2</span><span class="pn">)</span><span class="pn">,</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs30', 95)" onmouseover="showTip(event, 'fs30', 95)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;*&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 96)" onmouseover="showTip(event, 'fs30', 96)" class="fn">expression</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 97)" onmouseover="showTip(event, 'fs25', 97)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 98)" onmouseover="showTip(event, 'fs26', 98)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 99)" onmouseover="showTip(event, 'fs25', 99)" class="fn">x1</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs26', 100)" onmouseover="showTip(event, 'fs26', 100)" class="fn">x2</span><span class="pn">)</span><span class="pn">,</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs30', 101)" onmouseover="showTip(event, 'fs30', 101)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;/&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 102)" onmouseover="showTip(event, 'fs30', 102)" class="fn">expression</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 103)" onmouseover="showTip(event, 'fs25', 103)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 104)" onmouseover="showTip(event, 'fs26', 104)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 105)" onmouseover="showTip(event, 'fs25', 105)" class="fn">x1</span> <span class="o">/</span> <span onmouseout="hideTip(event, 'fs26', 106)" onmouseover="showTip(event, 'fs26', 106)" class="fn">x2</span><span class="pn">)</span><span class="pn">,</span>
        <span class="o">!&amp;</span> <span class="s">&quot;-&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 107)" onmouseover="showTip(event, 'fs30', 107)" class="fn">expression</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs36', 108)" onmouseover="showTip(event, 'fs36', 108)" class="fn">prec</span> <span onmouseout="hideTip(event, 'fs31', 109)" onmouseover="showTip(event, 'fs31', 109)" class="fn">NEG</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs37', 110)" onmouseover="showTip(event, 'fs37', 110)" class="fn">x</span> <span class="k">-&gt;</span> <span class="o">-</span><span onmouseout="hideTip(event, 'fs37', 111)" onmouseover="showTip(event, 'fs37', 111)" class="fn">x</span><span class="pn">)</span><span class="pn">,</span>
        <span class="o">!@</span> <span onmouseout="hideTip(event, 'fs30', 112)" onmouseover="showTip(event, 'fs30', 112)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;^&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 113)" onmouseover="showTip(event, 'fs30', 113)" class="fn">expression</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 114)" onmouseover="showTip(event, 'fs25', 114)" class="fn">x1</span> <span onmouseout="hideTip(event, 'fs26', 115)" onmouseover="showTip(event, 'fs26', 115)" class="fn">x2</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 116)" onmouseover="showTip(event, 'fs38', 116)" class="id">Math</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs39', 117)" onmouseover="showTip(event, 'fs39', 117)" class="id">Pow</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs25', 118)" onmouseover="showTip(event, 'fs25', 118)" class="fn">x1</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs26', 119)" onmouseover="showTip(event, 'fs26', 119)" class="fn">x2</span><span class="pn">)</span><span class="pn">)</span><span class="pn">,</span>
        <span class="c">// We use |&gt; asIs instead of =&gt; (fun x -&gt; x).</span>
        <span class="o">!&amp;</span> <span class="s">&quot;(&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs30', 120)" onmouseover="showTip(event, 'fs30', 120)" class="fn">expression</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;)&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs35', 121)" onmouseover="showTip(event, 'fs35', 121)" class="fn">asIs</span>
    <span class="pn">)</span>

    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs40', 122)" onmouseover="showTip(event, 'fs40', 122)" class="fn">opScope</span> <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs41', 123)" onmouseover="showTip(event, 'fs41', 123)" class="fn">OperatorScope</span><span class="pn">(</span>
            <span onmouseout="hideTip(event, 'fs42', 124)" onmouseover="showTip(event, 'fs42', 124)" class="fn">LeftAssociative</span><span class="pn">(</span><span class="s">&quot;+&quot;</span><span class="pn">,</span> <span class="s">&quot;-&quot;</span><span class="pn">)</span><span class="pn">,</span>
            <span onmouseout="hideTip(event, 'fs42', 125)" onmouseover="showTip(event, 'fs42', 125)" class="fn">LeftAssociative</span><span class="pn">(</span><span class="s">&quot;*&quot;</span><span class="pn">,</span> <span class="s">&quot;/&quot;</span><span class="pn">)</span><span class="pn">,</span>
            <span onmouseout="hideTip(event, 'fs43', 126)" onmouseover="showTip(event, 'fs43', 126)" class="fn">PrecedenceOnly</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs31', 127)" onmouseover="showTip(event, 'fs31', 127)" class="fn">NEG</span><span class="pn">)</span><span class="pn">,</span>
            <span onmouseout="hideTip(event, 'fs44', 128)" onmouseover="showTip(event, 'fs44', 128)" class="fn">RightAssociative</span><span class="pn">(</span><span class="s">&quot;^&quot;</span><span class="pn">)</span>
        <span class="pn">)</span>

    <span onmouseout="hideTip(event, 'fs45', 129)" onmouseover="showTip(event, 'fs45', 129)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs46', 130)" onmouseover="showTip(event, 'fs46', 130)" class="id">withOperatorScope</span> <span onmouseout="hideTip(event, 'fs40', 131)" onmouseover="showTip(event, 'fs40', 131)" class="fn">opScope</span> <span onmouseout="hideTip(event, 'fs30', 132)" onmouseover="showTip(event, 'fs30', 132)" class="fn">expression</span>
</code></pre>
<p>As you see, our grammar in Farkle looks pretty similar to the one in Bison. Let's take a look at some newly introduced things:</p>
<h3><a name="Defining-recursive-nonterminals" class="anchor" href="#Defining-recursive-nonterminals">Defining recursive nonterminals</a></h3>
<p>The <code>nonterminal</code> function is useful for recursive nonterminals. It creates a nonterminal whose productions will be set later with the <code>SetProductions</code> method. We can only once set them, all together. Calling the method again will have no effect.</p>
<p>Our nonterminal is of type <code>Nonterminal&lt;float&gt;</code>, but implements the <code>DesigntimeFarkle&lt;float&gt;</code> interface.</p>
<h3><a name="Operator-Precedence" class="anchor" href="#Operator-Precedence">Operator Precedence</a></h3>
<p>We specify the operator associativity and precedence using an <em>operator scope</em> that is made of <em>associativity groups</em>. There are four associativity group types: <code>LeftAssociative</code>, <code>RightAssociative</code>, <code>NonAssociative</code> and <code>PrecedenceOnly</code> that behave similarly to Bison's <code>%left</code>, <code>%right</code>, <code>%nonassoc</code> and <code>%precedence</code>. Their difference is best explained <a href="https://www.gnu.org/software/bison/manual/html_node/Using-Precedence.html">at Bison's documentation</a>.</p>
<p>The groups in an operator scope are sorted by precedence in ascending order. In our grammar, the <code>+</code> and <code>-</code> symbols have the lowest precedence, followed by <code>*</code> and <code>/</code>. Until now, all these operators are left-associative, meaning that <code>1 + 2 + 3</code> is interpreted as <code>(1 + 2) + 3</code>.</p>
<p>Next in the precedence hierarchy is the unary negation. We can't define <code>-</code> again; instead we use the <code>prec</code> function to assign the unary negation's production a <em>contextual reflection token</em>, which is a dummy object that represents the production in the operator scope. This way, Farkle will recognize that <code>-</code> has higher precedence in unary negation than in subtraction. That new group is of type <code>PrecedenceOnly</code>, meaning that it doesn't specify associativity; only precedence.</p>
<p>And at the highest priority we have the exponentiation operator, which is right associative, meaning that <code>2 ^ 3 ^ 4</code> is interpreted as <code>2 ^ (3 ^ 4)</code>.</p>
<p>We set this operator scope to our designtime Farkle using the <code>DesigntimeFarkle.withOperatorScope</code> function. There are some more things to be careful about when using operator scopes:</p>
<ul>
<li>Setting a second operator scope to a designtime Farkle will discard the one that was previous set.</li>
<li>An operator can belong in only one operator scope. Otherwise undefined behavior will occur.</li>
</ul>
<h2><a name="Building-our-grammar" class="anchor" href="#Building-our-grammar">Building our grammar</a></h2>
<p>With our nonterminals being ready, it's time to create a runtime Farkle that can parse mathematical expressions. The builder will create tables for the parser using the LALR algorithm, and a Deterministic Finite Automaton (DFA) for the tokenizer. It also creates a special object called a <em>post-processor</em> that is responsible for executing the transformers and fusers.</p>
<p>All that stuff can be done with a single line of code:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs47', 133)" onmouseover="showTip(event, 'fs47', 133)" class="id">myMarvelousRuntimeFarkle</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs48', 134)" onmouseover="showTip(event, 'fs48', 134)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs49', 135)" onmouseover="showTip(event, 'fs49', 135)" class="id">build</span> <span onmouseout="hideTip(event, 'fs30', 136)" onmouseover="showTip(event, 'fs30', 136)" class="id">expression</span>
</code></pre>
<h2><a name="Using-the-runtime-Farkle" class="anchor" href="#Using-the-runtime-Farkle">Using the runtime Farkle</a></h2>
<p>Now that we got it, it's time to put it to action. Farkle supports parsing text from various sources, namely strings, arbitrary character buffers on the heap (like substrings, arrays or parts of arrays) using <code>System.ReadOnlyMemory&lt;char&gt;</code>, files and <code>System.IO.TextReader</code>s.</p>
<p>The functions return an F# <code>Result</code> type whose error value (if it unfortunately exists), can show exactly what did go wrong.</p>
<blockquote>
<p><strong>Note:</strong> If a grammar is invalid (has an LALR conflict, two terminals are indistinguishable or something else), building would still succeed, but parsing would fail every time.</p>
</blockquote>
<p>Let's look at some some examples:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs3', 137)" onmouseover="showTip(event, 'fs3', 137)" class="id">System</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs50', 138)" onmouseover="showTip(event, 'fs50', 138)" class="id">IO</span>

<span class="c">// You can consume the parsing result like this:</span>
<span class="k">match</span> <span onmouseout="hideTip(event, 'fs48', 139)" onmouseover="showTip(event, 'fs48', 139)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs51', 140)" onmouseover="showTip(event, 'fs51', 140)" class="id">parseString</span> <span onmouseout="hideTip(event, 'fs47', 141)" onmouseover="showTip(event, 'fs47', 141)" class="id">myMarvelousRuntimeFarkle</span> <span class="s">&quot;103 + 137+281&quot;</span> <span class="k">with</span>
<span class="pn">|</span> <span onmouseout="hideTip(event, 'fs52', 142)" onmouseover="showTip(event, 'fs52', 142)" class="uc">Ok</span> <span onmouseout="hideTip(event, 'fs53', 143)" onmouseover="showTip(event, 'fs53', 143)" class="fn">result</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs54', 144)" onmouseover="showTip(event, 'fs54', 144)" class="fn">printfn</span> <span class="s">&quot;The answer is </span><span class="pf">%f</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs53', 145)" onmouseover="showTip(event, 'fs53', 145)" class="fn">result</span>
<span class="c">// The %O format specifier (or alternatively, calling ToString())</span>
<span class="c">// will create human-readable error messages.</span>
<span class="pn">|</span> <span onmouseout="hideTip(event, 'fs55', 146)" onmouseover="showTip(event, 'fs55', 146)" class="uc">Error</span> <span onmouseout="hideTip(event, 'fs56', 147)" onmouseover="showTip(event, 'fs56', 147)" class="fn">err</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs54', 148)" onmouseover="showTip(event, 'fs54', 148)" class="fn">printfn</span> <span class="s">&quot;Error: </span><span class="pf">%O</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs56', 149)" onmouseover="showTip(event, 'fs56', 149)" class="fn">err</span>

<span class="c">// You can parse any Memory&lt;char&gt;, such a substring or even an array of characters!</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 150)" onmouseover="showTip(event, 'fs57', 150)" class="id">mem</span> <span class="o">=</span> <span class="s">&quot;The answer is 45&quot;</span><span class="pn">.</span><span class="id">AsMemory</span><span class="pn">(</span><span class="pn">)</span><span class="pn">.</span><span class="id">Slice</span><span class="pn">(</span><span class="n">14</span><span class="pn">)</span>
<span onmouseout="hideTip(event, 'fs48', 151)" onmouseover="showTip(event, 'fs48', 151)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs58', 152)" onmouseover="showTip(event, 'fs58', 152)" class="id">parseMemory</span> <span onmouseout="hideTip(event, 'fs47', 153)" onmouseover="showTip(event, 'fs47', 153)" class="id">myMarvelousRuntimeFarkle</span> <span onmouseout="hideTip(event, 'fs57', 154)" onmouseover="showTip(event, 'fs57', 154)" class="id">mem</span>

<span onmouseout="hideTip(event, 'fs48', 155)" onmouseover="showTip(event, 'fs48', 155)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs59', 156)" onmouseover="showTip(event, 'fs59', 156)" class="id">parseFile</span> <span onmouseout="hideTip(event, 'fs47', 157)" onmouseover="showTip(event, 'fs47', 157)" class="id">myMarvelousRuntimeFarkle</span> <span class="s">&quot;example.txt&quot;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs60', 158)" onmouseover="showTip(event, 'fs60', 158)" class="d">myStringReader</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs61', 159)" onmouseover="showTip(event, 'fs61', 159)" class="d">StringReader</span><span class="pn">(</span><span class="s">&quot;45 + 198 - 647 + 2 * 478 - 488 + 801 - 248&quot;</span><span class="pn">)</span>
<span onmouseout="hideTip(event, 'fs48', 160)" onmouseover="showTip(event, 'fs48', 160)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs62', 161)" onmouseover="showTip(event, 'fs62', 161)" class="id">parseTextReader</span> <span onmouseout="hideTip(event, 'fs47', 162)" onmouseover="showTip(event, 'fs47', 162)" class="id">myMarvelousRuntimeFarkle</span> <span onmouseout="hideTip(event, 'fs60', 163)" onmouseover="showTip(event, 'fs60', 163)" class="d">myStringReader</span>
</code></pre>
<h2><a name="Customizing-our-designtime-Farkle" class="anchor" href="#Customizing-our-designtime-Farkle">Customizing our designtime Farkle</a></h2>
<p>Before we finish, let's take a look at one more thing; how to further customize a designtime Farkle.</p>
<ul>
<li>Most programming languages have comments, so why would Farkle not support them as well? We can create a designtime Farkle that adds support for comments in another one. Both block and line comments are supported. They cannot be nested.</li>
<li>By default, grammars are not case sensitive. But we can make them if we want.</li>
<li>By default, whitespace characters are ignored. We can change it once again.</li>
<li><p>We can also specify a symbol that will be discarded when encountered by the parser. These symbols are called <em>noise symbols</em> and are defined by regexes.</p></li>
</ul>
<p>We will see some customizations as an example:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs63', 164)" onmouseover="showTip(event, 'fs63', 164)" class="id">_customized</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs30', 165)" onmouseover="showTip(event, 'fs30', 165)" class="id">expression</span>
    <span class="c">// You can add as many types of block or line comments as you want.</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs45', 166)" onmouseover="showTip(event, 'fs45', 166)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs64', 167)" onmouseover="showTip(event, 'fs64', 167)" class="id">addBlockComment</span> <span class="s">&quot;/*&quot;</span> <span class="s">&quot;*/&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs45', 168)" onmouseover="showTip(event, 'fs45', 168)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs65', 169)" onmouseover="showTip(event, 'fs65', 169)" class="id">addLineComment</span> <span class="s">&quot;//&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs45', 170)" onmouseover="showTip(event, 'fs45', 170)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs66', 171)" onmouseover="showTip(event, 'fs66', 171)" class="id">caseSensitive</span> <span class="k">true</span>
    <span class="c">// Whether to ignore whitespace between terminals; true by default.</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs45', 172)" onmouseover="showTip(event, 'fs45', 172)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs67', 173)" onmouseover="showTip(event, 'fs67', 173)" class="id">autoWhitespace</span> <span class="k">false</span>
    <span class="c">// Adds an arbitrary symbol that will be ignored by Farkle.</span>
    <span class="c">// It needs a regex, and a name for diagnostics purposes.</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs45', 174)" onmouseover="showTip(event, 'fs45', 174)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs68', 175)" onmouseover="showTip(event, 'fs68', 175)" class="id">addNoiseSymbol</span> <span class="s">&quot;Letters&quot;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs17', 176)" onmouseover="showTip(event, 'fs17', 176)" class="fn">chars</span> <span onmouseout="hideTip(event, 'fs69', 177)" onmouseover="showTip(event, 'fs69', 177)" class="id">AllLetters</span><span class="pn">)</span>
</code></pre>
<blockquote>
<p><strong>Note:</strong> These customizations have to be done at the top-level designtime Farkle that is going to be built (or they will have no effect) and always apply to the entire grammar.</p>
</blockquote>
<hr />
<p>So, I hope you enjoyed this little tutorial. If you did, don't forget to give Farkle a try, and maybe you have any question, found a bug, or want a feature, and want to <a href="https://github.com/teo-tsirpanis/farkle/issues">open a GitHub issue</a> as well. I hope that all of you have a wonderful day and to see you soon. Goodbye!</p>

            <div class="fsdocs-tip" id="fs1">namespace Farkle</div>
<div class="fsdocs-tip" id="fs2">namespace Farkle.Builder</div>
<div class="fsdocs-tip" id="fs3">namespace System</div>
<div class="fsdocs-tip" id="fs4">val number: DesigntimeFarkle&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs5">module Terminals

from Farkle.Builder<br /><em>&lt;summary&gt;Some designtime Farkles that
 are commonly used in many grammars.&lt;/summary&gt;<br />&lt;remarks&gt;
 These functions take a name and create
 a designtime Farkle which is meant to be
 reused everywhere it is needed in the grammar.
 Creating and using many designtime Farkles
 of the same or similar kind
 will almost certainly lead to an error.&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs6">val genericReal: allowSign: bool -&gt; name: string -&gt; DesigntimeFarkle&lt;&#39;TReal&gt; (requires member Parse)<br /><em>&lt;summary&gt;
 Creates a designtime Farkle that parses a real number
 into the desired number type. No bounds checking is performed.
 Using this function from a language other than F# will throw an exception.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs7">Multiple items<br />val float: value: &#39;T -&gt; float (requires member op_Explicit)<br /><br />--------------------<br />type float = Double<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; =
  float</div>
<div class="fsdocs-tip" id="fs8">val numberStringRegex: DesigntimeFarkle&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs9">Multiple items<br />module Regex

from Farkle.Builder<br /><em>&lt;summary&gt;
 F#-friendly members of the `Regex` class.
 Please consult the members of the `Regex` class for documentation.
&lt;/summary&gt;</em><br /><br />--------------------<br />type Regex =
  private | Concat of Regex list
          | Alt of Regex list
          | Star of Regex
          | Chars of Set&lt;char&gt;
          | AllButChars of Set&lt;char&gt;
          | RegexString of RegexStringHolder
  member And: x2: Regex -&gt; Regex
  member AtLeast: num: int -&gt; Regex
  member Between: from: int -&gt; upTo: int -&gt; Regex
  member Optional: unit -&gt; Regex
  member Or: x2: Regex -&gt; Regex
  member Repeat: num: int -&gt; Regex
  member ZeroOrMore: unit -&gt; Regex
  static member Choice: [&lt;ParamArray&gt;] regexes: Regex array -&gt; Regex
  static member FromRegexString: x: string -&gt; Regex
  static member Join: [&lt;ParamArray&gt;] regexes: Regex array -&gt; Regex
  ...<br /><em>&lt;summary&gt;A regular expression that is used to specify a tokenizer symbol.&lt;/summary&gt;<br />&lt;remarks&gt;Checking two regular expressions for equality does not mean that they
 recognize the same symbols, but that their internal structure is the same.&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs10">val regexString: x: string -&gt; Regex</div>
<div class="fsdocs-tip" id="fs11">val terminal: name: string -&gt; fTransform: T&lt;&#39;a&gt; -&gt; regex: Regex -&gt; DesigntimeFarkle&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
 Creates a terminal with the given name, specified by the given `Regex`.
 Its content will be post-processed by the given `T` delegate.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs12">T (ITransformerContext -&gt; ReadOnlySpan&lt;char&gt; -&gt; float)<br /><em>&lt;summary&gt;A delegate that transforms the content
 of a terminal to an arbitrary object.&lt;/summary&gt;<br />&lt;param name=&quot;context&quot;&gt;An &lt;see cref=&quot;ITransformerContext&quot; /&gt;
 that provides additional info about the terminal.&lt;/param&gt;<br />&lt;param name=&quot;data&quot;&gt;A read-only span of the terminal&#39;s characters.&lt;/param&gt;<br />&lt;remarks&gt;&lt;para&gt;In F# this type is shortened to
 &lt;c&gt;T&lt;/c&gt; to avoid clutter in user code.&lt;/para&gt;&lt;para&gt;A .NET delegate was used because read-only
 spans are incompatible with F# functions.&lt;/para&gt;&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs13">val x: ReadOnlySpan&lt;char&gt;</div>
<div class="fsdocs-tip" id="fs14">ReadOnlySpan.ToString() : string</div>
<div class="fsdocs-tip" id="fs15">val numberConstructedRegex: DesigntimeFarkle&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs16">val atLeastOneNumber: Regex</div>
<div class="fsdocs-tip" id="fs17">val chars: str: char seq -&gt; Regex<br /><em>&lt;summary&gt;
 An alias for `Regex.OneOf`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs18">module PredefinedSets

from Farkle.Builder<br /><em>&lt;summary&gt;
 Some common character sets that were imported from GOLD Parser.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs19">val Number: PredefinedSet</div>
<div class="fsdocs-tip" id="fs20">val atLeast: num: int -&gt; x: Regex -&gt; Regex</div>
<div class="fsdocs-tip" id="fs21">val concat: xs: Regex seq -&gt; Regex</div>
<div class="fsdocs-tip" id="fs22">val optional: x: Regex -&gt; Regex</div>
<div class="fsdocs-tip" id="fs23">Multiple items<br />val char: c: char -&gt; Regex<br /><em>&lt;summary&gt;
 An alias for `Regex.Literal` that takes a character.
&lt;/summary&gt;</em><br /><br />--------------------<br />type char = Char</div>
<div class="fsdocs-tip" id="fs24">val justTwoNumbers: DesigntimeFarkle&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs25">val x1: float</div>
<div class="fsdocs-tip" id="fs26">val x2: float</div>
<div class="fsdocs-tip" id="fs27">val empty: ProductionBuilder<br /><em>&lt;summary&gt;
 An alias for `ProductionBuilder.Empty`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs28">val exp: value: &#39;T -&gt; &#39;T (requires member Exp)</div>
<div class="fsdocs-tip" id="fs29">namespace Farkle.Builder.OperatorPrecedence</div>
<div class="fsdocs-tip" id="fs30">val expression: Nonterminal&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs31">val NEG: obj</div>
<div class="fsdocs-tip" id="fs32">type obj = Object</div>
<div class="fsdocs-tip" id="fs33">val nonterminal: name: string -&gt; Nonterminal&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
 Creates a `Nonterminal` whose productions must be
 later set with `SetProductions`, or it will raise an
 error on building. Useful for recursive productions.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs34">abstract Nonterminal.SetProductions: firstProd: Production&lt;&#39;T&gt; * [&lt;ParamArray&gt;] prods: Production&lt;&#39;T&gt; array -&gt; unit</div>
<div class="fsdocs-tip" id="fs35">val asIs: pb: ProductionBuilders.ProductionBuilder&lt;&#39;T&gt; -&gt; Production&lt;&#39;T&gt;<br /><em>&lt;summary&gt;
 An alias for ``ProductionBuilder`1.AsIs``.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs36">val prec: token: obj -&gt; pb: &#39;TBuilder -&gt; &#39;TBuilder (requires member WithPrecedence)<br /><em>&lt;summary&gt;
 An alias for the `WithPrecedence` method of production builders.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs37">val x: float</div>
<div class="fsdocs-tip" id="fs38">type Math =
  static member Abs: value: decimal -&gt; decimal + 7 overloads
  static member Acos: d: float -&gt; float
  static member Acosh: d: float -&gt; float
  static member Asin: d: float -&gt; float
  static member Asinh: d: float -&gt; float
  static member Atan: d: float -&gt; float
  static member Atan2: y: float * x: float -&gt; float
  static member Atanh: d: float -&gt; float
  static member BigMul: a: int * b: int -&gt; int64 + 2 overloads
  static member BitDecrement: x: float -&gt; float
  ...<br /><em>&lt;summary&gt;Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs39">Math.Pow(x: float, y: float) : float</div>
<div class="fsdocs-tip" id="fs40">val opScope: OperatorScope</div>
<div class="fsdocs-tip" id="fs41">Multiple items<br />type OperatorScope =
  new: resolvesReduceReduceConflicts: bool * assocGroups: AssociativityGroup seq -&gt; OperatorScope + 2 overloads
  member ResolvesReduceReduceConflict: bool
  static member Empty: OperatorScope<br /><em>&lt;summary&gt;A group of associativity groups sorted by precedence.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;A symbol in an operator scope has higher precedence than
 another one if it appears in a group below the former symbol&#39;s group.&lt;/para&gt;&lt;para&gt;If the same symbol is specified in multiple associativity groups,
 it will have the precedence of the earliest group in which it appeared.&lt;/para&gt;&lt;para&gt;Symbols from multiple operator scopes cannot be compared for precedence.&lt;/para&gt;&lt;para&gt;A symbol can belong in only one operator scope; if it belongs in more,
 the operator scope to which the symbol will be assigned is undefined.&lt;/para&gt;&lt;para&gt;Operator scopes are used to automatically resolve Shift-Reduce conflicts.
 Resolving Reduce-Reduce conflicts can also happen but it must be explicitly
 opt-in by passing a boolean argument of &lt;see langword=&quot;true&quot; /&gt; in the first
 argument of the appropriate operator scope&#39;s constructor overloads.&lt;/para&gt;&lt;/remarks&gt;</em><br /><br />--------------------<br />new: [&lt;ParamArray&gt;] assocGroups: AssociativityGroup array -&gt; OperatorScope<br />new: resolvesReduceReduceConflicts: bool * assocGroups: AssociativityGroup seq -&gt; OperatorScope<br />new: resolveReduceReduceConflicts: bool * [&lt;ParamArray&gt;] assocGroups: AssociativityGroup array -&gt; OperatorScope</div>
<div class="fsdocs-tip" id="fs42">Multiple items<br />type LeftAssociative =
  inherit AssociativityGroup
  new: [&lt;ParamArray&gt;] symbols: obj array -&gt; LeftAssociative<br /><em>&lt;summary&gt;
 A shortcut for creating left-associative groups.
&lt;/summary&gt;</em><br /><br />--------------------<br />new: [&lt;ParamArray&gt;] symbols: obj array -&gt; LeftAssociative</div>
<div class="fsdocs-tip" id="fs43">Multiple items<br />type PrecedenceOnly =
  inherit AssociativityGroup
  new: [&lt;ParamArray&gt;] symbols: obj array -&gt; PrecedenceOnly<br /><em>&lt;summary&gt;
 A shortcut for creating associativity groups with only precedence and no associativity between them.
&lt;/summary&gt;</em><br /><br />--------------------<br />new: [&lt;ParamArray&gt;] symbols: obj array -&gt; PrecedenceOnly</div>
<div class="fsdocs-tip" id="fs44">Multiple items<br />type RightAssociative =
  inherit AssociativityGroup
  new: [&lt;ParamArray&gt;] symbols: obj array -&gt; RightAssociative<br /><em>&lt;summary&gt;
 A shortcut for creating right-associative groups.
&lt;/summary&gt;</em><br /><br />--------------------<br />new: [&lt;ParamArray&gt;] symbols: obj array -&gt; RightAssociative</div>
<div class="fsdocs-tip" id="fs45">Multiple items<br />module DesigntimeFarkle

from Farkle.Builder<br /><em>&lt;summary&gt;
 Functions to set metadata for designtime Farkles.
 With few exceptions, these functions will have to be applied to the topmost
 designtime Farkle that will get build, or they will have no effect.
 Designime Farkles that were applied the functions of this module must not
 be used with the original designtime Farkles in the same context; only
 one grammar symbol will be created, with undefined behavior.
&lt;/summary&gt;</em><br /><br />--------------------<br />type DesigntimeFarkle =
  abstract Metadata: GrammarMetadata
  abstract Name: string<br /><em>&lt;summary&gt;The base interface of &lt;see cref=&quot;DesigntimeFarkle{T}&quot; /&gt;.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;In contrast with its typed descendant, untyped designtime
 Farkles do not return any value. They typically represent literal symbols
 that can only take one value. Building an untyped designtime Farkle will
 result in a syntax-checking runtime Farkle with no custom post-processor.&lt;/para&gt;&lt;para&gt;User code must not implement this interface,
 or an exception might be thrown.&lt;/para&gt;&lt;/remarks&gt;<br />&lt;seealso cref=&quot;DesigntimeFarkle{T}&quot; /&gt;</em><br /><br />--------------------<br />type DesigntimeFarkle&lt;&#39;T&gt; =
  inherit DesigntimeFarkle<br /><em>&lt;summary&gt;An object representing a grammar symbol created by Farkle.Builder.
 It corresponds to either a standalone terminal or a nonterminal
 that contains other designtime Farkles.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;Designtime Farkles cannot be used to parse text but can be
 composed into larger designtime Farkles. To actually use them, they
 have to be converted to a &lt;see cref=&quot;RuntimeFarkle{T}&quot; /&gt; which however
 is not composable. This one-way conversion is performed by the &lt;c&gt;RuntimeFarkle.build&lt;/c&gt;
 function or the &lt;c&gt;Build&lt;/c&gt; extension method.&lt;/para&gt;&lt;para&gt;This interface has no members on its own; they are
 inherited from &lt;see cref=&quot;DesigntimeFarkle&quot; /&gt;.&lt;/para&gt;&lt;para&gt;User code must not implement this interface,
 or an exception might be thrown.&lt;/para&gt;&lt;/remarks&gt;<br />&lt;typeparam name=&quot;T&quot;&gt;The type of the objects this grammar generates.&lt;/typeparam&gt;<br />&lt;seealso cref=&quot;DesigntimeFarkle&quot; /&gt;</em></div>
<div class="fsdocs-tip" id="fs46">val withOperatorScope: opScope: OperatorScope -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Sets an `OperatorScope` object to a designtime Farkle.
 This function can be applied in designtime Farkles that are not the
 topmost ones. Applying this function many times will discard the existing
 operator scope.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs47">val myMarvelousRuntimeFarkle: RuntimeFarkle&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs48">Multiple items<br />module RuntimeFarkle

from Farkle<br /><em>&lt;summary&gt;
 Functions to create and use `RuntimeFarkle`s.
&lt;/summary&gt;</em><br /><br />--------------------<br />type RuntimeFarkle&lt;&#39;TResult&gt; =
  private {
            Grammar: Result&lt;Grammar,BuildError list&gt;
            PostProcessor: PostProcessor&lt;&#39;TResult&gt;
            TokenizerFactory: TokenizerFactory
          }
  interface IGrammarProvider
  member Cast: unit -&gt; RuntimeFarkle&lt;obj&gt;
  member ChangePostProcessor: pp: PostProcessor&lt;&#39;TNewResult&gt; -&gt; RuntimeFarkle&lt;&#39;TNewResult&gt;
  member ChangeTokenizer: tokenizerFactory: TokenizerFactory -&gt; RuntimeFarkle&lt;&#39;TResult&gt; + 1 overload
  member GetBuildErrorMessage: unit -&gt; string
  member GetBuildErrors: unit -&gt; BuildError list
  member GetGrammar: unit -&gt; Grammar
  member Parse: input: CharStream -&gt; Result&lt;&#39;TResult,FarkleError&gt; + 3 overloads
  member ParseFile: path: string -&gt; Result&lt;&#39;TResult,FarkleError&gt;
  member SyntaxCheck: unit -&gt; RuntimeFarkle&lt;obj&gt;
  ...<br /><em>&lt;summary&gt;A reusable parser and post-processor,
 created for a specific grammar, and returning
 a specific type of object that best describes
 an expression of the language of this grammar.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;Its parsing methods return an F# result
 type containing either the post-processed return
 type, or a type describing what did wrong and where.&lt;/para&gt;&lt;para&gt;Exceptions during post-processing (apart from
 &lt;see cref=&quot;ParserApplicationException&quot; /&gt;) are thrown
 after being wrapped in a &lt;see cref=&quot;PostProcessorException&quot; /&gt;.&lt;/para&gt;&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs49">val build: df: DesigntimeFarkle&lt;&#39;a&gt; -&gt; RuntimeFarkle&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
 Creates a `RuntimeFarkle` from the given `DesigntimeFarkle&amp;amp;lt;&#39;T&amp;amp;gt;`.
 In case there is a problem with the grammar, the `RuntimeFarkle` will
 fail every time it is used. If the designtime Farkle is marked for
 precompilation and a suitable precompiled grammar is found, it will be ignored.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs50">namespace System.IO</div>
<div class="fsdocs-tip" id="fs51">val parseString: rf: RuntimeFarkle&lt;&#39;a&gt; -&gt; inputString: string -&gt; Result&lt;&#39;a,FarkleError&gt;<br /><em>&lt;summary&gt;
 Parses and post-processes a string.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs52">union case Result.Ok: ResultValue: &#39;T -&gt; Result&lt;&#39;T,&#39;TError&gt;</div>
<div class="fsdocs-tip" id="fs53">val result: float</div>
<div class="fsdocs-tip" id="fs54">val printfn: format: Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T</div>
<div class="fsdocs-tip" id="fs55">union case Result.Error: ErrorValue: &#39;TError -&gt; Result&lt;&#39;T,&#39;TError&gt;</div>
<div class="fsdocs-tip" id="fs56">val err: FarkleError</div>
<div class="fsdocs-tip" id="fs57">val mem: ReadOnlyMemory&lt;char&gt;</div>
<div class="fsdocs-tip" id="fs58">val parseMemory: rf: RuntimeFarkle&lt;&#39;a&gt; -&gt; input: ReadOnlyMemory&lt;char&gt; -&gt; Result&lt;&#39;a,FarkleError&gt;<br /><em>&lt;summary&gt;
 Parses and post-processes a `ReadOnlyMemory` of characters.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs59">val parseFile: rf: RuntimeFarkle&lt;&#39;a&gt; -&gt; path: string -&gt; Result&lt;&#39;a,FarkleError&gt;<br /><em>&lt;summary&gt;
 Parses and post-processes a file at the given path.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs60">val myStringReader: StringReader</div>
<div class="fsdocs-tip" id="fs61">Multiple items<br />type StringReader =
  inherit TextReader
  new: s: string -&gt; unit
  member Close: unit -&gt; unit
  member Peek: unit -&gt; int
  member Read: unit -&gt; int + 2 overloads
  member ReadAsync: buffer: char array * index: int * count: int -&gt; Task&lt;int&gt; + 1 overload
  member ReadBlock: buffer: Span&lt;char&gt; -&gt; int
  member ReadBlockAsync: buffer: char array * index: int * count: int -&gt; Task&lt;int&gt; + 1 overload
  member ReadLine: unit -&gt; string
  member ReadLineAsync: unit -&gt; Task&lt;string&gt; + 1 overload
  ...<br /><em>&lt;summary&gt;Implements a &lt;see cref=&quot;T:System.IO.TextReader&quot; /&gt; that reads from a string.&lt;/summary&gt;</em><br /><br />--------------------<br />StringReader(s: string) : StringReader</div>
<div class="fsdocs-tip" id="fs62">val parseTextReader: rf: RuntimeFarkle&lt;&#39;a&gt; -&gt; textReader: TextReader -&gt; Result&lt;&#39;a,FarkleError&gt;<br /><em>&lt;summary&gt;
 Parses and post-processes a .NET `TextReader`. Its content is lazily read.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs63">val _customized: Nonterminal&lt;float&gt;</div>
<div class="fsdocs-tip" id="fs64">val addBlockComment: commentStart: string -&gt; commentEnd: string -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Adds a block comment to the given `DesigntimeFarkle`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs65">val addLineComment: commentStart: string -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Adds a line comment to the given `DesigntimeFarkle`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs66">val caseSensitive: flag: bool -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Sets the `CaseSensitive` field of a `DesigntimeFarkle`&#39;s metadata.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs67">val autoWhitespace: flag: bool -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Sets the `AutoWhitespace` field of a `DesigntimeFarkle`&#39;s metadata.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs68">val addNoiseSymbol: name: string -&gt; regex: Regex -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Adds a name-`Regex` pair of noise symbols to the given `DesigntimeFarkle`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs69">val AllLetters: PredefinedSet</div>

        </div>
    </div>

    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <script type="text/javascript">var fsdocs_search_baseurl = 'https://teo-tsirpanis.github.io/Farkle/';</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
    <script async type="text/javascript" src="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-search.js"></script>
    <!-- END SEARCH BOX: this adds support for the search box -->
  </body>

</html>