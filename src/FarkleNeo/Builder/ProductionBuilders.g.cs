// <auto-generated/>
// This file was automatically generated by Farkle's build system from a Scriban template.
// It should not be manually edited; to regenerate it run 'build.ps1 target GenerateCode'.

#nullable enable

namespace Farkle.Builder.ProductionBuilders;

using Farkle.Builder;
using Farkle.Parser;
using System;
using System.Collections.Immutable;
using System.ComponentModel;

/// <summary>A production builder with 16 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, _idx16;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, int idx12, int idx13, int idx14, int idx15, int idx16, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11; _idx12 = idx12; _idx13 = idx13; _idx14 = idx14; _idx15 = idx15; _idx16 = idx16;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, _idx16, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11; int idx12 = _idx12; int idx13 = _idx13; int idx14 = _idx14; int idx15 = _idx15; int idx16 = _idx16;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!, (T12)args[idx12]!, (T13)args[idx13]!, (T14)args[idx14]!, (T15)args[idx15]!, (T16)args[idx16]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, _idx16, precedenceToken);
    }
}

/// <summary>A production builder with 15 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, int idx12, int idx13, int idx14, int idx15, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11; _idx12 = idx12; _idx13 = idx13; _idx14 = idx14; _idx15 = idx15;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T16">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Extend<T16>(IGrammarSymbol<T16> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11; int idx12 = _idx12; int idx13 = _idx13; int idx14 = _idx14; int idx15 = _idx15;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!, (T12)args[idx12]!, (T13)args[idx13]!, (T14)args[idx14]!, (T15)args[idx15]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _idx15, precedenceToken);
    }
}

/// <summary>A production builder with 14 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, int idx12, int idx13, int idx14, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11; _idx12 = idx12; _idx13 = idx13; _idx14 = idx14;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T15">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Extend<T15>(IGrammarSymbol<T15> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11; int idx12 = _idx12; int idx13 = _idx13; int idx14 = _idx14;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!, (T12)args[idx12]!, (T13)args[idx13]!, (T14)args[idx14]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _idx14, precedenceToken);
    }
}

/// <summary>A production builder with 13 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, int idx12, int idx13, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11; _idx12 = idx12; _idx13 = idx13;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T14">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Extend<T14>(IGrammarSymbol<T14> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11; int idx12 = _idx12; int idx13 = _idx13;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!, (T12)args[idx12]!, (T13)args[idx13]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _idx13, precedenceToken);
    }
}

/// <summary>A production builder with 12 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, int idx12, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11; _idx12 = idx12;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T13">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Extend<T13>(IGrammarSymbol<T13> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11; int idx12 = _idx12;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!, (T12)args[idx12]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _idx12, precedenceToken);
    }
}

/// <summary>A production builder with 11 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, int idx11, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10; _idx11 = idx11;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T12">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Extend<T12>(IGrammarSymbol<T12> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10; int idx11 = _idx11;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!, (T11)args[idx11]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _idx11, precedenceToken);
    }
}

/// <summary>A production builder with 10 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, int idx10, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9; _idx10 = idx10;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T11">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Extend<T11>(IGrammarSymbol<T11> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9; int idx10 = _idx10;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!, (T10)args[idx10]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _idx10, precedenceToken);
    }
}

/// <summary>A production builder with 9 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, int idx9, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8; _idx9 = idx9;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T10">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Extend<T10>(IGrammarSymbol<T10> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8; int idx9 = _idx9;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!, (T9)args[idx9]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _idx9, precedenceToken);
    }
}

/// <summary>A production builder with 8 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, int idx8, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7; _idx8 = idx8;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T9">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8, T9> Extend<T9>(IGrammarSymbol<T9> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7; int idx8 = _idx8;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!, (T8)args[idx8]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _idx8, precedenceToken);
    }
}

/// <summary>A production builder with 7 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6, T7> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6; _idx7 = idx7;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6, T7>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T8">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7, T8> Extend<T8>(IGrammarSymbol<T8> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T7, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6; int idx7 = _idx7;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!, (T7)args[idx7]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _idx7, precedenceToken);
    }
}

/// <summary>A production builder with 6 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5, T6> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5, _idx6;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5; _idx6 = idx6;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5, T6>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T7">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6, T7> Extend<T7>(IGrammarSymbol<T7> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T6, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5; int idx6 = _idx6;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!, (T6)args[idx6]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, _idx6, precedenceToken);
    }
}

/// <summary>A production builder with 5 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4, T5> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4, _idx5;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, int idx5, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4; _idx5 = idx5;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4, T5>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T6">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5, T6> Extend<T6>(IGrammarSymbol<T6> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _idx5, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T5, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4; int idx5 = _idx5;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!, (T5)args[idx5]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4, T5> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, _idx5, precedenceToken);
    }
}

/// <summary>A production builder with 4 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3, T4> : IProductionBuilder<ProductionBuilder<T1, T2, T3, T4>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3, _idx4;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, int idx4, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3; _idx4 = idx4;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3, T4>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T5">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4, T5> Extend<T5>(IGrammarSymbol<T5> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _idx4, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T4, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3; int idx4 = _idx4;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!, (T4)args[idx4]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3, T4> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, _idx4, precedenceToken);
    }
}

/// <summary>A production builder with 3 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2, T3> : IProductionBuilder<ProductionBuilder<T1, T2, T3>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2, _idx3;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, int idx3, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2; _idx3 = idx3;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2, T3>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T4">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3, T4> Extend<T4>(IGrammarSymbol<T4> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _idx3, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T3, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2; int idx3 = _idx3;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!, (T3)args[idx3]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2, T3> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, _idx3, precedenceToken);
    }
}

/// <summary>A production builder with 2 significant members.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1, T2> : IProductionBuilder<ProductionBuilder<T1, T2>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1, _idx2;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, int idx2, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1; _idx2 = idx2;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1, T2>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T3">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2, T3> Extend<T3>(IGrammarSymbol<T3> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _idx2, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T2, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1; int idx2 = _idx2;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!, (T2)args[idx2]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <inheritdoc/>
    public ProductionBuilder<T1, T2> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, _idx2, precedenceToken);
    }
}

/// <summary>A production builder with 1 significant member.</summary>
/// <seealso cref="ProductionBuilder"/>
public sealed class ProductionBuilder<T1> : IProductionBuilder<ProductionBuilder<T1>>
{
    private readonly ImmutableList<IGrammarSymbol> _members;
    private readonly object? _precedenceToken;
    private readonly int _idx1;

    internal ProductionBuilder(ImmutableList<IGrammarSymbol> members, int idx1, object? precedenceToken)
    {
        _members = members;
        _idx1 = idx1;
        _precedenceToken = precedenceToken;
    }

    void IProductionBuilder<ProductionBuilder<T1>>.MustNotImplement() { }

    /// <inheritdoc/>
    public ProductionBuilder<T1> Append(IGrammarSymbol symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _precedenceToken);
    }

    /// <summary>
    /// Extends the production with a new significant member.
    /// </summary>
    /// <typeparam name="T2">The type of the new significant member.</typeparam>
    /// <param name="symbol">The new significant member.</param>
    /// <returns>A production builder with <paramref name="symbol"/> added to its end as a significant member.</returns>
    public ProductionBuilder<T1, T2> Extend<T2>(IGrammarSymbol<T2> symbol)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(symbol);
        return new(_members.Add(symbol), _idx1, _members.Count, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return the result of applying
    /// the given function to the significant members.
    /// </summary>
    /// <param name="fuser">The function to apply to the significant members.</param>
    public IProduction<T> Finish<T>(Func<T1, T> fuser)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(fuser);
        int idx1 = _idx1;
        object? fBoxed(ref ParserState state, Span<object?> args) =>
            fuser((T1)args[idx1]!);
        // We don't use [.. _members] because it generates more IL.
        return new Production<T>(_members.ToImmutableArray(), fBoxed, _precedenceToken);
    }

    /// <summary>
    /// Finishes building the production, making it return its single significant member unchanged.
    /// </summary>
    public IProduction<T1> AsProduction() => Finish(x => x);

    /// <summary>
    /// Obsolete, use <see cref="AsProduction"/> instead.
    /// </summary>
    [Obsolete(Obsoletions.AsIsApiMessage
#if NET5_0_OR_GREATER
        , DiagnosticId = Obsoletions.AsIsApiCode, UrlFormat = Obsoletions.SharedUrlFormat
#endif
    ), EditorBrowsable(EditorBrowsableState.Never)]
    public IProduction<T1> AsIs() => AsProduction();

    /// <inheritdoc/>
    public ProductionBuilder<T1> WithPrecedence(object precedenceToken)
    {
        ArgumentNullExceptionCompat.ThrowIfNull(precedenceToken);
        return new(_members, _idx1, precedenceToken);
    }
}

