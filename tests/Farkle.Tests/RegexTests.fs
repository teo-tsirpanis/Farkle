// Copyright (c) 2019 Theodore Tsirpanis
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

module Farkle.Tests.RegexTests

open Expecto
open Farkle
open Farkle.Builder
open Farkle.Tests
open FsCheck
open System

let getDfa(x: CharParser<_>) = x.GetGrammar().DfaOnChar

[<Tests>]
let tests = testList "Regex tests" [
    testProperty "Regex.optional is idempotent" (fun regex ->
        let opt1 = Regex.optional regex
        let opt2 = Regex.optional opt1
        opt1 = opt2
    )

    testProperty "Regex.ZeroOrMore is idempotent" (fun regex ->
        let star1 = Regex.star regex
        let star2 = Regex.star star1
        star1 = star2)

    // The default size makes tests run for too long
    testPropertySmall "A DFA generated by regular expressions recognizes all of them" (fun (Regexes (regexes, strings)) ->
        let parser = buildSimpleRegexMatcher true regexes
        // Some regexes might turn out to be indistinguishable.
        // It's quite unlikely, but we cannot predict it, so we just ignore it.
        if not parser.IsFailing then
            strings
            |> List.iter (fun (str, i) ->
                let actualSymbol = expectWantParseSuccess (CharParser.parseString parser str) "The string was not recognized"
                Expect.equal actualSymbol i "A different string was recognized")
    )

    test "Overriding case sensitivity in individual regexes works" {
        let regexes =
            [
                Regex.string "a"
                Regex.string "b" |> Regex.caseSensitive
            ]
        let parser = buildSimpleRegexMatcher false regexes
        expectIsParseSuccess (CharParser.parseString parser "a") "The lowercase string did not match the case-insensitive regex"
        expectIsParseSuccess (CharParser.parseString parser "A") "The uppercase string did not match the case-insensitive regex"
        expectIsParseSuccess (CharParser.parseString parser "b") "The lowercase string did not match the case-sensitive regex"
        expectIsParseFailure (CharParser.parseString parser "B") "The uppercase string did match the case-sensitive regex"
    }

    testPropertySmall "A case insensitive DFA recognizes strings regardless of their capitalization" (fun (RegexStringPair (regex, str)) ->
        let dfa =
            buildSimpleRegexMatcher false [regex]
        expectIsParseSuccess (CharParser.parseString dfa str) "Recognizing the original string failed"
        expectIsParseSuccess (CharParser.parseString dfa <| str.ToLowerInvariant()) "Recognizing the lowercase string failed"
        expectIsParseSuccess (CharParser.parseString dfa <| str.ToUpperInvariant()) "Recognizing the uppercase string failed"
    )

    testProperty "The DFA builder can correctly prioritize literal symbols over a wildcard" (fun (literals: uint32 list) ->
        let literals = literals |> List.distinct |> List.map string
        // By limiting the characters to just the decimal digits,
        // the test becomes more fast. In the past it was by far
        // the slowest test.
        let ident = Regex.charRanges ['0', '9'] |> Regex.atLeast 1
        let parser =
            literals
            |> List.map Regex.string
            |> (fun xs -> ident :: xs)
            |> buildSimpleRegexMatcherEx true true
        literals
        |> Seq.indexed
        |> Seq.forall (fun (i, str) ->
            let result = expectWantParseSuccess (CharParser.parseString parser str) "Parsing the number failed"
            result = i + 1)
    )

    testProperty "A DFA for a literal string is minimal" (fun (NonNull str) ->
        let dfa =
            [Regex.string str]
            |> buildSimpleRegexMatcher true
            |> getDfa
        Expect.hasLength dfa (str.Length + 1) "The DFA is not minimal")

    test "The DFA for a regex matching the empty string has the expected shape" {
        let dfa =
            [Regex.string ""]
            |> buildSimpleRegexMatcher true
            |> getDfa
        Expect.hasLength dfa 1 "The DFA does not have one state"
        let state = dfa[0]
        Expect.isEmpty state.Edges "The state has edges"
        Expect.equal state.DefaultTransition -1 "The state has a default transition"
        Expect.hasLength state.AcceptSymbols 1 "The state does not have an accepting symbol"
    }

    test "Titlecase letters are correctly handled when building a case-insensitive DFA" {
        let regex = Regex.char 'ǅ'
        let dfa =
            [regex]
            |> buildSimpleRegexMatcher false
            |> getDfa

        "Ǆǅǆ"
        |> String.iter (fun c ->
            dfa.[0].Edges
            |> Seq.exists (fun x -> x.KeyFrom <= c && c <= x.KeyTo)
            |> Flip.Expect.isTrue $"%c{c} is not recognized")
    }

    test "Anything Else edges are removed from a DFA when there is an edge for every character" {
        let regex1 = Regex.chars [Char.MinValue .. Char.MaxValue]
        let regex2 = Regex.allButChars "a"

        let dfa =
            buildSimpleRegexMatcher true [regex1; regex2]
            |> getDfa
        // Before Farkle 7 the DFA had two states because on character
        // "a" regex1 takes precedence over regex2. Since Farkle 7,
        // both regexes are followed, so the DFA has three states;
        // the initial state, the state after "a" and the state for
        // characters before and after "a".
        Expect.equal dfa.Count 3 "The DFA does not have three states"
        Expect.equal dfa.[0].DefaultTransition -1 "The unreachable Anything Else edge was not removed"
    }

    test "DFA conflicts between terminals and noise symbols are resolved in favor of the former" {
        let parser =
            Regex.regexString ".+"
            |> terminalU "MyTerminal"
            |> _.AddNoiseSymbol("Noise", Regex.string "aaa")
            |> _.BuildSyntaxCheck()
        Expect.isFalse parser.IsFailing "Building the grammar failed"
        expectIsParseSuccess (CharParser.parseString parser "aaa") "The terminal was not recognized"
    }

    test "DFA conflicts between noise symbols do not cause a build error" {
        let parser =
            Regex.string "x"
            |> terminalU "MyTerminal"
            |> _.AddNoiseSymbol("Noise1", Regex.regexString "a|b|c")
            |> _.AddNoiseSymbol("Noise2", Regex.regexString "a|d|e")
            |> _.BuildSyntaxCheck()
        Expect.isFalse parser.IsFailing "Building the grammar failed"
    }

#if false // TODO-FARKLE7: Reevaluate when the builder is implemented in Farkle 7.
    test "DFA conflict messages come with a correct example word" {
        let impl regex1 regex2 exampleWord =
            let term1 = Terminal(0u, "A") |> Choice1Of4
            let term2 = Terminal(1u, "B") |> Choice1Of4
            let dfaErrors =
                DFABuild.buildRegexesToDFA false true [Regex.regexString regex1, term1; Regex.regexString regex2, term2]
                |> Flip.Expect.wantError (sprintf "The regexes %s and %s do not conflict" regex1 regex2)
            let expectedErrors =
                [BuildError.IndistinguishableSymbols2(set [term1; term2], exampleWord)]
            Expect.sequenceEqual dfaErrors expectedErrors "The DFA did not contain the expected error"

        [
            ".\d", ".[0-5]", "a0"
            "[^\u0000-\uFFFE]", "[^a]", "\uFFFF"
            // Finding examples that would trigger the unassigned character finder's various code
            // paths is difficult. We just test a few examples and throw on the actual code if
            // it ever reaches a wrong conclusion.
        ]
        |> List.iter ((<|||) impl)
    }
#endif
]
