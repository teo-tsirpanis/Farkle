// Copyright (c) 2019 Theodore Tsirpanis
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

module Farkle.Tests.RegexTests

open Expecto
open Farkle.Builder
open Farkle.Grammar
open Farkle.Tests
open FsCheck
open System

let terminal idx = Choice1Of4 <| Terminal(uint32 idx, string idx)

[<Tests>]
let tests = testList "Regex tests" [
    testProperty "Regex.optional is idempotent" (fun regex ->
        let opt1 = Regex.optional regex
        let opt2 = Regex.optional opt1
        opt1 = opt2
    )

    testProperty "Regex.ZeroOrMore is idempotent" (fun regex ->
        let star1 = Regex.atLeast 0 regex
        let star2 = Regex.atLeast 0 star1
        star1 = star2)

    testProperty "Chaining Regex.And works the same with Regex.Concat" (fun regexes ->
        let chained = Array.fold (<&>) Regex.Empty regexes
        let concatenated = Regex.Join regexes
        chained = concatenated
    )

    // The default size makes tests run for too long
    testPropertySmall "A DFA generated by regular expressions recognizes all of them" (fun (Regexes (regexes, strings)) ->
        let dfa = DFABuild.buildRegexesToDFA false true regexes
        match dfa with
        | Ok dfa ->
            List.forall (fun (str, sym) -> match matchDFAToString dfa str with | Some x -> x = sym | _ -> false) strings
        // Some regexes might turn out to be indistinguishable.
        // It's quite unlikely, but we cannot predict it, so we just ignore it.
        | Error _ -> true
    )

    testPropertySmall "A case insensitive DFA recognizes strings regardless of their capitalization" (fun (RegexStringPair (regex, str)) ->
        let dfa =
            DFABuild.buildRegexesToDFA false false [regex, Choice1Of4 <| Terminal(0u, "My Terminal")]
            // We have only one regex. It cannot fail by accident.
            |> Flip.Expect.wantOk "Generating a case insensitive DFA failed"
        Expect.isSome (matchDFAToString dfa str) "Recognizing the original string failed"
        Expect.isSome (matchDFAToString dfa <| str.ToLowerInvariant()) "Recognizing the lowercase string failed"
        Expect.isSome (matchDFAToString dfa <| str.ToUpperInvariant()) "Recognizing the uppercase string failed"
    )

    testProperty "A DFA can correctly recognize literal symbols over a wildcard" (fun (literals: uint32 list) ->
        let literals = literals |> List.distinct |> List.map string
        // By limiting the characters to just the decimal digits,
        // the test becomes more fast. In the past it was by far
        // the slowest test.
        let ident = (Regex.chars ['0' .. '9'] |> Regex.atLeast 1, Choice1Of4 <| Terminal(0u, "Identifier"))
        let dfa =
            literals
            |> List.mapi (fun i str -> Regex.string str, Choice1Of4 <| Terminal(uint32 i + 1u, str))
            |> (fun xs -> ident :: xs)
            |> DFABuild.buildRegexesToDFA true true
            |> Flip.Expect.wantOk "Generating the DFA failed"
        literals
        |> List.forall (fun str ->
            match matchDFAToString dfa str with
            | Some(Choice1Of4(Terminal(_, term))) -> term = str
            | _ -> false)
    )

    testProperty "A DFA for a literal string is minimal" (fun (NonNull str) ->
        let dfa =
            [Regex.string str, Choice1Of4 <| Terminal(0u, str)]
            |> DFABuild.buildRegexesToDFA false true
            |> Flip.Expect.wantOk "Generating a DFA for a literal string failed"
        Expect.hasLength dfa (str.Length + 1) "The DFA is not minimal")

    // It fails on Windows when using NLS (including the AppVeyor CI which uses Windows Server).
    ptest "Titlecase letters are correctly handled when building a case-insensitive DFA" {
        let term = Terminal(0u, "A") |> Choice1Of4
        let regex = Regex.char 'ǅ'
        let dfa =
            DFABuild.buildRegexesToDFA true false [regex, term]
            |> Flip.Expect.wantOk "Generating the DFA failed"

        "Ǆǅǆ"
        |> String.iter (fun c ->
            dfa.[0].Edges.ContainsKey c
            |> Flip.Expect.isTrue (sprintf "%c is not recognized" c))
    }

    test "Anything Else edges are removed from a DFA when there is an edge for every character" {
        let term1 = Terminal(0u, "A") |> Choice1Of4
        let regex1 = Regex.chars [Char.MinValue .. Char.MaxValue]
        let term2 = Terminal(1u, "B") |> Choice1Of4
        let regex2 = Regex.allButChars "a"

        let dfa =
            DFABuild.buildRegexesToDFA true true [regex1, term1; regex2, term2]
            |> Flip.Expect.wantOk "Generating the DFA failed"
        Expect.equal dfa.Length 2 "The DFA did not have two states"
        Expect.isNone dfa.[0].AnythingElse "The unreachable Anything Else edge was not removed"
    }

    test "DFA conflict messages come with a correct example word" {
        let impl regex1 regex2 exampleWord =
            let term1 = Terminal(0u, "A") |> Choice1Of4
            let term2 = Terminal(1u, "B") |> Choice1Of4
            let dfaErrors =
                DFABuild.buildRegexesToDFA false true [Regex.regexString regex1, term1; Regex.regexString regex2, term2]
                |> Flip.Expect.wantError (sprintf "The regexes %s and %s do not conflict" regex1 regex2)
            let expectedErrors =
                [BuildError.IndistinguishableSymbols2(set [term1; term2], exampleWord)]
            Expect.sequenceEqual dfaErrors expectedErrors "The DFA did not contain the expected error"

        [
            ".\d", ".[0-5]", "a0"
            "[^\u0000-\uFFFE]", "[^a]", "\uFFFF"
            // Finding examples that would trigger the unassigned character finder's various code
            // paths is difficult. We just test a few examples and throw on the actual code if
            // it ever reaches a wrong conclusion.
        ]
        |> List.iter ((<|||) impl)
    }
]
