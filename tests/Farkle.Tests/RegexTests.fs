// Copyright (c) 2019 Theodore Tsirpanis
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

module Farkle.Tests.RegexTests

open Expecto
open Farkle
open Farkle.Builder
open Farkle.Tests
open FsCheck
open System

let getDfa(x: CharParser<_>) = x.GetGrammar().DfaOnChar

[<Tests>]
let tests = testList "Regex tests" [
    testProperty "Regex.optional is idempotent" (fun regex ->
        let opt1 = Regex.optional regex
        let opt2 = Regex.optional opt1
        opt1 = opt2
    )

    testProperty "Regex.ZeroOrMore is idempotent" (fun regex ->
        let star1 = Regex.atLeast 0 regex
        let star2 = Regex.atLeast 0 star1
        star1 = star2)

    testProperty "Chaining Regex.And works the same with Regex.Concat" (fun regexes ->
        let chained = Seq.fold (+) Regex.Empty regexes
        let concatenated = Regex.Join regexes
        chained = concatenated
    )

    // The default size makes tests run for too long
    testPropertySmall "A DFA generated by regular expressions recognizes all of them" (fun (Regexes (regexes, strings)) ->
        let parser = buildSimpleRegexMatcher true regexes
        if parser.IsFailing then
            // Some regexes might turn out to be indistinguishable.
            // It's quite unlikely, but we cannot predict it, so we just ignore it.
            true
        else
            strings
            |> List.forall (fun (str, i) ->
                expectWantParseSuccess (CharParser.parseString parser str) "The string was not recognized" = i)
    )

    testPropertySmall "A case insensitive DFA recognizes strings regardless of their capitalization" (fun (RegexStringPair (regex, str)) ->
        let dfa =
            buildSimpleRegexMatcher false [regex]
        expectIsParseSuccess (CharParser.parseString dfa str) "Recognizing the original string failed"
        expectIsParseSuccess (CharParser.parseString dfa <| str.ToLowerInvariant()) "Recognizing the lowercase string failed"
        expectIsParseSuccess (CharParser.parseString dfa <| str.ToUpperInvariant()) "Recognizing the uppercase string failed"
    )

    testProperty "A DFA can correctly recognize literal symbols over a wildcard" (fun (literals: uint32 list) ->
        let literals = literals |> List.distinct |> List.map string
        // By limiting the characters to just the decimal digits,
        // the test becomes more fast. In the past it was by far
        // the slowest test.
        let ident = Regex.charRanges ['0', '9'] |> Regex.atLeast 1
        let parser =
            literals
            |> List.map Regex.string
            |> (fun xs -> ident :: xs)
            |> buildSimpleRegexMatcher true
        literals
        |> Seq.indexed
        |> Seq.forall (fun (i, str) ->
            let result = expectWantParseSuccess (CharParser.parseString parser str) "Parsing the number failed"
            result = i + 1)
    )

    testProperty "A DFA for a literal string is minimal" (fun (NonNull str) ->
        let dfa =
            [Regex.string str]
            |> buildSimpleRegexMatcher true
            |> getDfa
        Expect.hasLength dfa (str.Length + 1) "The DFA is not minimal")

    test "Titlecase letters are correctly handled when building a case-insensitive DFA" {
        let regex = Regex.char 'ǅ'
        let dfa =
            [regex]
            |> buildSimpleRegexMatcher false
            |> getDfa

        "Ǆǅǆ"
        |> String.iter (fun c ->
            dfa.[0].Edges
            |> Seq.exists (fun x -> x.KeyFrom <= c && c <= x.KeyTo)
            |> Flip.Expect.isTrue $"%c{c} is not recognized")
    }

    test "Anything Else edges are removed from a DFA when there is an edge for every character" {
        let regex1 = Regex.chars [Char.MinValue .. Char.MaxValue]
        let regex2 = Regex.allButChars "a"

        let dfa =
            buildSimpleRegexMatcher true [regex1; regex2]
            |> getDfa
        // Before Farkle 7 the DFA had two states because on character
        // "a" regex1 takes precedence over regex2. Since Farkle 7,
        // both regexes are followed, so the DFA has three states;
        // the initial state, the state after "a" and the state for
        // characters before and after "a".
        Expect.equal dfa.Count 3 "The DFA does not have three states"
        Expect.equal dfa.[0].DefaultTransition -1 "The unreachable Anything Else edge was not removed"
    }

#if false // TODO-FARKLE7: Reevaluate when the builder is implemented in Farkle 7.
    test "DFA conflict messages come with a correct example word" {
        let impl regex1 regex2 exampleWord =
            let term1 = Terminal(0u, "A") |> Choice1Of4
            let term2 = Terminal(1u, "B") |> Choice1Of4
            let dfaErrors =
                DFABuild.buildRegexesToDFA false true [Regex.regexString regex1, term1; Regex.regexString regex2, term2]
                |> Flip.Expect.wantError (sprintf "The regexes %s and %s do not conflict" regex1 regex2)
            let expectedErrors =
                [BuildError.IndistinguishableSymbols2(set [term1; term2], exampleWord)]
            Expect.sequenceEqual dfaErrors expectedErrors "The DFA did not contain the expected error"

        [
            ".\d", ".[0-5]", "a0"
            "[^\u0000-\uFFFE]", "[^a]", "\uFFFF"
            // Finding examples that would trigger the unassigned character finder's various code
            // paths is difficult. We just test a few examples and throw on the actual code if
            // it ever reaches a wrong conclusion.
        ]
        |> List.iter ((<|||) impl)
    }
#endif
]
