// Copyright (c) 2019 Theodore Tsirpanis
// 
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

module Farkle.Tests.RegexTests

open Expecto
open Farkle.Builder
open Farkle.Collections
open Farkle.Grammar
open Farkle.Tests
open FsCheck

/// A simple, less efficient function to check if a string is recognized by a DFA.
let matchDFAToString (states: StateTable<DFAState>) str =
    let rec impl currState x =
        if x = "" then
            currState.AcceptSymbol
        else
            match RangeMap.tryFind x.[0] currState.Edges with
            | ValueSome s -> impl states.States.[int s] (x.Substring(1))
            | ValueNone -> None
    impl states.InitialState str

[<Tests>]
let tests = testList "Regex tests" [
    testProperty "Regex.optional is idempotent" (fun regex ->
        let opt1 = Regex.optional regex
        let opt2 = Regex.optional opt1
        opt1 = opt2
    )

    testProperty "Regex.ZeroOrMore is idempotent" (fun regex ->
        let star1 = Regex.atLeast 0 regex
        let star2 = Regex.atLeast 0 star1
        star1 = star2)

    testProperty "Chaining Regex.And works the same with Regex.Concat" (fun regexes ->
        let chained = Array.fold (<&>) Regex.Empty regexes
        let concatenated = Regex.Join regexes
        chained = concatenated |@ (sprintf "\nChained: %A\nConcatenated = %A" chained concatenated)
    )

    testProperty "A DFA generated by regular expressions recognizes all of them" (fun (Regexes (regexes, strings)) ->
        let dfa = RegexBuild.buildRegexesToDFA true regexes
        match dfa with
        | Ok dfa ->
            List.forall (fun (str, sym) -> match matchDFAToString dfa str with | Some x -> x = sym | _ -> false) strings
        | Error _ -> true)
]
