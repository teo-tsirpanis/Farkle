<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Farkle's precompiler
</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Theodore Tsirpanis">
  <meta name="description" content="Farkle - Farkle's precompiler
">

  <link rel="stylesheet" id="theme_link" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.6.0/materia/bootstrap.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" integrity="sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF" crossorigin="anonymous"></script>

  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/navbar-fixed-left.css" />
  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-default.css" />
  <link type="text/css" rel="stylesheet" href="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-custom.css" />
  <style>
    .container img {
      max-height: 100%;
      max-width: 100%;
    }
  </style>
  <script async type="text/javascript" src="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-tips.js"></script>
  <!-- BEGIN SEARCH BOX: this adds support for the search box -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
  <!-- END SEARCH BOX: this adds support for the search box -->
</head>

  <body>
    <nav class="navbar navbar-expand-md navbar-light bg-secondary fixed-left" id="fsdocs-nav">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <a href="https://teo-tsirpanis.github.io/Farkle/index.html"><img id="fsdocs-logo" src="https://teo-tsirpanis.github.io/Farkle/img/logo.png" /></a>
        <!-- BEGIN SEARCH BOX: this adds support for the search box -->
        <div id="header">
          <div class="searchbox" id="fsdocs-searchbox">
            <input data-search-input="" id="search-by" type="search" placeholder="Search..." />
          </div>
        </div>
        <!-- END SEARCH BOX: this adds support for the search box -->

        <ul class="navbar-nav">
          <li class="nav-header">Links</li>
          <li class="nav-item"><a class="nav-link" href="https://nuget.org/packages/Farkle">Get Library via NuGet</a></li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/teo-tsirpanis/Farkle">Source Code on GitHub</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/license.html">License</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/release-notes.html">Release Notes</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/choosing-a-parser.html">Choosing a parser: Farkle vs alternatives</a></li>

          <li class="nav-header">Getting started</li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/quickstart.html">Quick Start with F#</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/csharp.html">Using Farkle with C#</a></li>

          <li class="nav-header">Documentation</li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/reference/index.html">API Reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/templates.html">Templating Reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/string-regexes.html">String regex reference</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/the-precompiler.html">The precompiler</a></li>
          <li class="nav-item"><a class="nav-link" href="https://teo-tsirpanis.github.io/Farkle/advanced-features.html">Advanced Features</a></li>
        </ul>
      </div>
    </nav>
    <div class="container">
        <div class="masthead">
            <h3 class="muted"><a href="https://teo-tsirpanis.github.io/Farkle/index.html">Farkle</a></h3>
        </div>
        <hr />
        <div class="container" id="fsdocs-content">
            <h1><a name="Farkle-s-precompiler" class="anchor" href="#Farkle-s-precompiler">Farkle's precompiler</a></h1>
<p>Every time an app using Farkle starts, it builds the parser tables for its grammars. This process takes some time and it will take even more if the app does not reuse the runtime Farkles it creates.</p>
<p>Most apps need to parse a static grammar whose specification never changes between program executions. For example, a compiler or a JSON parsing library will parse text from the same language every time you use them. Farkle would spend time building these parsing tables that do not depend on user input and will always be the same. It wouldn't hurt a program like a web app parsing lots of input strings, but for a compiler that parses only one file per invocation, building that grammar every time the program runs would impose an unnecessary overhead, maybe more than the time spent for the rest of the program if the grammar is big.</p>
<p>What is more, Farkle does not report any grammar error (such as an LALR conflict) until it's too late: text was attempted to be parsed with a faulty grammar. Wouldn't it be better if these errors were caught earlier in the app's development lifecycle?</p>
<p>One of Farkle's new features that came with version 6 is called <em>the precompiler</em>. The precompiler addresses this inherent limitation of Farkle's grammars being objects defined in code. Instead of building them every time, the grammar's parser tables are built <em>ahead of time</em> and stored in the program's assembly when it gets compiled. When that program is executed, instead of building the parser tables, it loads the precompiled grammar from the assembly, which is orders of magnitude faster.</p>
<blockquote>
<p><a href="#Building-from-an-IDE"><strong>Using the precompiler with Visual Studio for Windows requires extra steps.</strong></a></p>
</blockquote>
<h2><a name="How-to-use-it" class="anchor" href="#How-to-use-it">How to use it</a></h2>
<p>Using the precompiler does not differ very much from regularly using Farkle.</p>
<h3><a name="Preparing-the-your-code" class="anchor" href="#Preparing-the-your-code">Preparing the your code</a></h3>
<p>In F# designtime Farkles can be marked to be precompiled by applying the <code>RuntimeFarkle.markForPrecompile</code> function at the end. To build them, instead of using <code>RuntimeFarkle.build</code>, you have to use <code>RuntimeFarkle.buildPrecompiled</code> like in the example:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">Farkle</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 2)" onmouseover="showTip(event, 'fs1', 2)" class="id">Farkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 3)" onmouseover="showTip(event, 'fs2', 3)" class="id">Builder</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs3', 4)" onmouseover="showTip(event, 'fs3', 4)" class="id">precompilableDesigntime</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs4', 5)" onmouseover="showTip(event, 'fs4', 5)" class="fn">int</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 6)" onmouseover="showTip(event, 'fs5', 6)" class="m">Terminals</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="id">int</span> <span class="s">&quot;Integer&quot;</span>
    <span class="s">&quot;My complicated language&quot;</span>
    <span class="o">||=</span> <span class="pn">[</span><span class="o">!@</span> <span onmouseout="hideTip(event, 'fs4', 8)" onmouseover="showTip(event, 'fs4', 8)" class="fn">int</span> <span class="pn">.</span><span class="o">&gt;&gt;</span> <span class="s">&quot;+&quot;</span> <span class="pn">.</span><span class="o">&gt;&gt;.</span> <span onmouseout="hideTip(event, 'fs4', 9)" onmouseover="showTip(event, 'fs4', 9)" class="fn">int</span> <span class="pn">=&gt;</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs7', 10)" onmouseover="showTip(event, 'fs7', 10)" class="fn">x</span> <span onmouseout="hideTip(event, 'fs8', 11)" onmouseover="showTip(event, 'fs8', 11)" class="fn">y</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 12)" onmouseover="showTip(event, 'fs7', 12)" class="fn">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs8', 13)" onmouseover="showTip(event, 'fs8', 13)" class="fn">y</span><span class="pn">)</span><span class="pn">]</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 14)" onmouseover="showTip(event, 'fs9', 14)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 15)" onmouseover="showTip(event, 'fs10', 15)" class="id">addLineComment</span> <span class="s">&quot;//&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 16)" onmouseover="showTip(event, 'fs9', 16)" class="m">DesigntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs11', 17)" onmouseover="showTip(event, 'fs11', 17)" class="id">addBlockComment</span> <span class="s">&quot;/*&quot;</span> <span class="s">&quot;*/&quot;</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs12', 18)" onmouseover="showTip(event, 'fs12', 18)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs13', 19)" onmouseover="showTip(event, 'fs13', 19)" class="id">markForPrecompile</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 20)" onmouseover="showTip(event, 'fs14', 20)" class="id">runtime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs12', 21)" onmouseover="showTip(event, 'fs12', 21)" class="m">RuntimeFarkle</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs15', 22)" onmouseover="showTip(event, 'fs15', 22)" class="id">buildPrecompiled</span> <span onmouseout="hideTip(event, 'fs3', 23)" onmouseover="showTip(event, 'fs3', 23)" class="id">precompilableDesigntime</span>
</code></pre>
<p>Untyped designtime Farkles can be marked for precompilation with the <code>markForPrecompileU</code> function and can be built using the <code>RuntimeFarkle.buildPrecompiledUntyped</code> function.</p>
<hr />
<p>In C# you have to call the <code>MarkForPrecompile</code> extension method and store its result in a field of type <code>PrecompilableDesigntimeFarkle</code> like the example:</p>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">using</span> Farkle;
<span class="k">using</span> Farkle.Builder;

<span class="k">public</span> <span class="k">class</span> MyLanguage {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime;
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> RuntimeFarkle&lt;<span class="k">int</span>&gt; Runtime;

    <span class="k">static</span> MyLanguage() {
        Designtime <span class="o">=</span>
            Nonterminal.Create(<span class="s">"My complicated language"</span>,
                beginning.Extended().Extend(middle).Extend(end).Finish((b, m, e) <span class="o">=</span><span class="o">&gt;</span> b <span class="o">+</span> m <span class="o">+</span> e))
            .AddLineComment(<span class="s">"//"</span>)
            .AddBlockComment(<span class="s">"/*"</span>, <span class="s">"*/"</span>)
            .MarkForPrecompile();

        Runtime <span class="o">=</span> Designtime.Build();
    }
}
</code></pre></td></tr></table>
<p>As you see, the building methods in C# have the same name as before. The type for untyped precompilable designime Farkles is <code>PrecompilableDesigntimeFarkle</code>, without a type parameter.</p>
<h3><a name="The-rules" class="anchor" href="#The-rules">The rules</a></h3>
<p>A precompilable designtime Farkle will be discovered and precompiled if it is declared in a <code>static readonly</code> <em>field</em>. In C# static properties with a getter are equivalent, as is in F# a let-bound value in a module, but it must not be mutable. Also, <code>static let</code>s in class declarations will not be recognized because they are not compiled as <code>readonly</code>.</p>
<p>This field can be of any visibility; public, internal, private, it doesn't matter. It will be detected even in nested classes or nested F# modules. It <em>cannot</em> however be declared in a generic type.</p>
<p>In addition, the precompilable designtime Farkle must be marked in the assembly it is declared. Let's see a counterexample:</p>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="c">// Assembly A</span>
<span class="k">public</span> <span class="k">class</span> AssemblyA {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime;

    <span class="k">static</span> AssemblyA() {
        Designtime <span class="o">=</span>
            <span class="c">// ...</span>
            .MarkForPrecompile();
    }
}

<span class="c">// Assembly B</span>
<span class="k">public</span> <span class="k">class</span> AssemblyB {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; WillNotBePrecompiled <span class="o">=</span>
        AssemblyA.Designtime;

    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; WillBePrecompiled <span class="o">=</span>
        AssemblyA.Designtime.InnerDesigntimeFarkle.MarkForPrecompile();
}
</code></pre></td></tr></table>
<p>The precompiler will raise warnings to help you abide by the rules above.</p>
<p>All precompilable designtime Farkles within an assembly must have different names, or an error will be raised. You can use the <code>DesigntimeFarkle.rename</code> function or the <code>Rename</code> extension method to rename a designtime Farkle before marking it as precompilable.</p>
<p>Multiple fields referencing the same precompilable designtime Farkle do not pose a problem and will be precompiled only once.</p>
<h3><a name="Preparing-your-project" class="anchor" href="#Preparing-your-project">Preparing your project</a></h3>
<p>With your designtime Farkles being ready to be precompiled, it's time to prepare your project file. Add a reference to <a href="https://www.nuget.org/packages/Farkle.Tools.MSBuild">the <code>Farkle.Tools.MSBuild</code> package</a> like that:</p>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="xml"><span class="k">&lt;</span><span class="i">ItemGroup</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- The example's version numbers might be outdated. --&gt;</span>
    <span class="k">&lt;</span><span class="i">PackageReference</span> <span class="o">Include</span><span class="k">="Farkle"</span> <span class="o">Version</span><span class="k">="6.3.0"</span> <span class="k">/&gt;</span>
    <span class="k">&lt;</span><span class="i">PackageReference</span> <span class="o">Include</span><span class="k">="Farkle.Tools.MSBuild"</span> <span class="o">Version</span><span class="k">="6.3.0"</span> <span class="o">PrivateAssets</span><span class="k">="all"</span> <span class="k">/&gt;</span>
<span class="k">&lt;/</span><span class="i">ItemGroup</span><span class="k">&gt;</span>
</code></pre></td></tr></table>
<blockquote>
<p><strong>Important:</strong> The packages <code>Farkle</code> and <code>Farkle.Tools.MSBuild</code> must be at the same version. You will get a warning since Farkle 6.4.0 if they are not.</p>
</blockquote>
<p>If you build your program now, you should get a message that your designtime Farkles' grammars got precompiled. Hooray! Your app's startup time will be now much faster.</p>
<p><strong>If you have marked your designtime Farkles as precompiled, using the precompiler is mandatory.</strong> Parsing will always eventually fail if you build a precompilable designtime Farkle without having used the precompiler.</p>
<h2><a name="Conflict-reports" class="anchor" href="#Conflict-reports">Conflict reports</a></h2>
<p>Since Farkle 6.3.0, if a grammar you were going to precompile has LALR conflicts, Farkle will not display each of them as build errors, but will generate an HTML report containing all the parser's states, including their conflicting actions. You can take a look at <a href="sample-conflict-report.html">a sample conflict report</a> for <a href="quickstart.html">the quick start guide's</a> mathematical expression grammar, if we had not added operator precedence and associativity.</p>
<p>This feature is enabled by default and is expected to make diagnosing grammars with conflicts much easier. However if you want for some reason to disable conflict reports, you can see how to do it on the next section.</p>
<p>The conflict reports are stored in a temporary location and will be cleaned by MSBuild rebuilding or cleaning the project. Their paths are written to the <code>@(FarkleGeneratedConflictReports)</code> item, which can be used by a custom MSBuild target to do things like copy them elsewhere or upload them as CI artifacts. Such targets need to run after <code>FarkleRunPrecompiler</code>.</p>
<h2><a name="Customizing-the-precompiler" class="anchor" href="#Customizing-the-precompiler">Customizing the precompiler</a></h2>
<p>The precompiler's behavior can be customized by the following MSBuild properties you can set in your project file:</p>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="xml"><span class="k">&lt;</span><span class="i">PropertyGroup</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- Set it to false to disable the precompiler. As stated above however,</span>
<span class="c">    disabling it will cause parsing these precompiled grammars to fail. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarkleEnablePrecompiler</span><span class="k">&gt;</span>false<span class="k">&lt;/</span><span class="i">FarkleEnablePrecompiler</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- If set to true, Farkle will generate an HTML page</span>
<span class="c">    describing each precompiled grammar. Defaults to false. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarkleGenerateHtml</span><span class="k">&gt;</span>true<span class="k">&lt;/</span><span class="i">FarkleGenerateHtml</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- If set to false, Farkle will not generate an HTML report if any</span>
<span class="c">    grammar has conflicts but display each of them as build errors.</span>
<span class="c">    Obsolete since Farkle 6.4.0. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarkleGenerateConflictReports</span><span class="k">&gt;</span>false<span class="k">&lt;/</span><span class="i">FarkleGenerateConflictReports</span><span class="k">&gt;</span>
    <span class="c">&lt;!-- New in Farkle 6.4.0, can allow both detailed build errors and</span>
<span class="c">    conflict reports to be emitted when the precompiler encounters conflicts.</span>
<span class="c">    Allowed values are: Both, ErrorsOnly, ReportOnly. If present,</span>
<span class="c">    FarkleGenerateConflictReports will be ignored. --&gt;</span>
    <span class="k">&lt;</span><span class="i">FarklePrecompilerErrorMode</span><span class="k">&gt;</span>Both<span class="k">&lt;/</span><span class="i">FarklePrecompilerErrorMode</span><span class="k">&gt;</span>
<span class="k">&lt;/</span><span class="i">PropertyGroup</span><span class="k">&gt;</span>
</code></pre></td></tr></table>
<p>The <code>FarkleGenerateHtml</code> property uses Farkle's templating engine which is described <a href="templates.html#Creating-HTML-pages">in its own page</a>.</p>
<p>Furthermore, Farkle's precompiler is based on <a href="https://github.com/teo-tsirpanis/Sigourney">Sigourney</a>, which can be globally disabled by setting the <code>SigourneyEnable</code> property to false.</p>
<h2><a name="Some-final-notes" class="anchor" href="#Some-final-notes">Some final notes</a></h2>
<h3><a name="Composability" class="anchor" href="#Composability">Composability</a></h3>
<p>The name "precompilable designtime Farkle" is a bit misleading, because these objects do not implement the <code>DesigntimeFarkle</code> interface. This means that you cannot compose a precompilable designtime Farkle to form a bigger grammar, as you can do with an actual designtime Farkle. This incompatibility ensures that you are using the <code>markForPrecompile</code> family of functions correctly, by applying them once at the end.</p>
<p>To get the actual designtime Farkle behind a precompilable one, you have to use the <code>InnerDesigntimeFarkle</code> property:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 24)" onmouseover="showTip(event, 'fs16', 24)" class="id">composable</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 25)" onmouseover="showTip(event, 'fs3', 25)" class="id">precompilableDesigntime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs17', 26)" onmouseover="showTip(event, 'fs17', 26)" class="id">InnerDesigntimeFarkle</span>
</code></pre>
<h3><a name="Beware-of-code-execution" class="anchor" href="#Beware-of-code-execution">Beware of code execution</a></h3>
<p>Farkle's precompiler executes part of your project's code; the necessary static constructors to create your precompilable designtime Farkles. This code can do literally anything, but it is your responsibility to keep it short and without adverse side-effects. Similarly, it is your responsibility to not build untrusted projects that use the precompiler. Consuming 3rd-party libraries with precompiled grammars however will not execute arbitrary code.</p>
<h3><a name="Beware-of-non-determinism" class="anchor" href="#Beware-of-non-determinism">Beware of non-determinism</a></h3>
<p>Farkle's precompiler was made for grammars that are fixed, which is the reason it only works on static readonly fields: once you created it in your code, you cannot change it. Otherwise, what good would the precompiler be?</p>
<p>You can always call a non-deterministic function like <code>DateTime.Now</code> that will make your designtime Farkle parse integers in the hexadecimal format in your birthday, and in the decimal format in all other days. If you build your app on your birthday, it will produce bizarre results on all the other days, and if you build it on a day other than your birthday, it will work every time, except on your birthday (the worst birthday present). <strong>Just don't do it.</strong> Farkle cannot be made to detect such things, and you are not getting any smarter by doing it.</p>
<h3><a name="Using-the-precompiler-in-AOT-environments" class="anchor" href="#Using-the-precompiler-in-AOT-environments">Using the precompiler in AOT environments</a></h3>
<p>The <code>markForPrecompile</code> family of functions use the <code>Assembly.GetCallingAssembly()</code> method to determine the assembly the precompiled grammar is in, but this function is not supported in AOT environments.</p>
<p>Farkle 6.5.0 introduced overloads to the <code>MarkForPrecompile</code> extension method that allow manually specifying the assembly. Here's how to use them in both languages:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs18', 27)" onmouseover="showTip(event, 'fs18', 27)" class="rt">Dummy</span> <span class="o">=</span> <span class="k">class</span> <span class="k">end</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 28)" onmouseover="showTip(event, 'fs19', 28)" class="id">designtime</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs20', 29)" onmouseover="showTip(event, 'fs20', 29)" class="fn">literal</span> <span class="s">&quot;foo&quot;</span>

<span class="c">// We get the assembly of a dummy type we defined. We could have also called Assembly.GetExecutingAssembly().</span>
<span class="c">// The extension methods are the same in both C# and F#; there are no equivalent curried functions.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 30)" onmouseover="showTip(event, 'fs21', 30)" class="id">worksInAot</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 31)" onmouseover="showTip(event, 'fs19', 31)" class="id">designtime</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs22', 32)" onmouseover="showTip(event, 'fs22', 32)" class="id">MarkForPrecompile</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 33)" onmouseover="showTip(event, 'fs23', 33)" class="k">typeof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs18', 34)" onmouseover="showTip(event, 'fs18', 34)" class="rt">Dummy</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">Assembly</span><span class="pn">)</span>
</code></pre>
<table class="pre"><tr><td class="snippet"><pre class="fssnip highlighted"><code lang="csharp"><span class="k">using</span> Farkle;
<span class="k">using</span> Farkle.Builder;

<span class="k">public</span> <span class="k">class</span> MyLanguage {
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> PrecompilableDesigntimeFarkle&lt;<span class="k">int</span>&gt; Designtime;
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> RuntimeFarkle&lt;<span class="k">int</span>&gt; Runtime;

    <span class="k">static</span> MyLanguage() {
        Designtime <span class="o">=</span>
            Nonterminal.Create(<span class="s">"My complicated language"</span>,
                beginning.Extended().Extend(middle).Extend(end).Finish((b, m, e) <span class="o">=</span><span class="o">&gt;</span> b <span class="o">+</span> m <span class="o">+</span> e))
            .AddLineComment(<span class="s">"//"</span>)
            .AddBlockComment(<span class="s">"/*"</span>, <span class="s">"*/"</span>)
            .MarkForPrecompile(<span class="k">typeof</span>(MyLanguage).Assembly);

        Runtime <span class="o">=</span> Designtime.Build();
    }
}
</code></pre></td></tr></table>
<h3><a name="Building-from-an-IDE" class="anchor" href="#Building-from-an-IDE">Building from an IDE</a></h3>
<p>And last but not least, until version 6.3.0, the precompiler would not work when building an app on a .NET Framework edition of MSBuild, such as Visual Studio for Windows or the <code>msbuild</code> command.</p>
<p>.NET Core and .NET (these terms are used interchangeably) have APIs that allow the precompiler to dynamically load an assembly, get its precompilable grammars, and unload it. To do the same thing on .NET Framework was extremely hard, which is why Farkle runs the precompiler on an external process, known as <em>precompiler worker</em>. To setup the precompiler worker, install the .NET tool <code>Farkle.Tools</code> with the following command:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">dotnet</span> <span class="id">tool</span> <span class="id">install</span> <span class="id">Farkle</span><span class="pn">.</span><span class="id">Tools</span>
</code></pre>
<p>The version of <code>Farkle.Tools</code> must be the same with the packages <code>Farkle</code> and <code>Farkle.Tools.MSBuild</code> you use in your project. Otherwise errors are very likely to occur. The tool must also be installed <em>locally</em>, otherwise Farkle will not see it.</p>
<p>The recommended way to build an app that uses the precompiler is through .NET SDK commands like <code>dotnet build</code>, <code>dotnet run</code> and <code>dotnet msbuild</code>. It is faster, more stable and more supported. Visual Studio for Windows cannot run MSBuild on .NET. <a href="https://developercommunity2.visualstudio.com/t/Allow-building-SDK-style-projects-with-t/1331985">A suggestion on Visual Studio Developer Community</a> has been filed but Microsoft responded that it won't be implemented anytime soon. Readers of this guide that are affected are encouraged to upvote the above suggestion. When not using Visual Studio for Windows, Farkle will raise a warning suggesting you to move to the .NET SDK.</p>
<p>Rider however can use the .NET edition of MSBuild with a simple workaround. Open its settings, go to "Build, Execution, Deployment", "Toolset and Build", "Use MSBuild version", and select an MSBuild executable from the .NET SDK (it typically has a <code>.dll</code> extension).</p>
<p><img src="img/rider_msbuild_workaround.png" alt="The Settings window in JetBrains Rider" /></p>
<p>The fact that the precompiler runs on .NET Core doesn't mean that it won't work on projects targeting the .NET Framework. Precompiling a .NET Framework assembly will still load it to the .NET Core-based precompiler. While it sometimes works due to a compatibility shim, don't hold your breath that it will always work and you'd better not precompile designtime Farkles in assemblies that use .NET Framework-only features like ASP.NET Web Forms. In such scenarios you are recommended to move your Farkle-specific code to a separate library targeting .NET Standard.</p>
<hr />
<p>So I hope you enjoyed this little tutorial. If you did, don't forget to give Farkle a try, and maybe you feel especially precompiled today, and want to hit the star button as well. I hope that all of you have an wonderful day, and to see you soon. Goodbye!</p>

            <div class="fsdocs-tip" id="fs1">namespace Farkle</div>
<div class="fsdocs-tip" id="fs2">namespace Farkle.Builder</div>
<div class="fsdocs-tip" id="fs3">val precompilableDesigntime: PrecompilableDesigntimeFarkle&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs4">Multiple items<br />val int: DesigntimeFarkle&lt;int&gt;<br /><br />--------------------<br />type int = int32<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; =
  int</div>
<div class="fsdocs-tip" id="fs5">module Terminals

from Farkle.Builder<br /><em>&lt;summary&gt;Some designtime Farkles that
 are commonly used in many grammars.&lt;/summary&gt;<br />&lt;remarks&gt;
 These functions take a name and create
 a designtime Farkle which is meant to be
 reused everywhere it is needed in the grammar.
 Creating and using many designtime Farkles
 of the same or similar kind
 will almost certainly lead to an error.&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs6">val int: name: string -&gt; DesigntimeFarkle&lt;int&gt;<br /><em>&lt;summary&gt;
 Creates a designtime Farkle that parses and returns a
 signed 32-bit signed integer. No bounds checking is performed.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs7">val x: int</div>
<div class="fsdocs-tip" id="fs8">val y: int</div>
<div class="fsdocs-tip" id="fs9">Multiple items<br />module DesigntimeFarkle

from Farkle.Builder<br /><em>&lt;summary&gt;
 Functions to set metadata for designtime Farkles.
 With few exceptions, these functions will have to be applied to the topmost
 designtime Farkle that will get build, or they will have no effect.
 Designime Farkles that were applied the functions of this module must not
 be used with the original designtime Farkles in the same context; only
 one grammar symbol will be created, with undefined behavior.
&lt;/summary&gt;</em><br /><br />--------------------<br />type DesigntimeFarkle =
  abstract Metadata: GrammarMetadata
  abstract Name: string<br /><em>&lt;summary&gt;The base interface of &lt;see cref=&quot;DesigntimeFarkle{T}&quot; /&gt;.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;In contrast with its typed descendant, untyped designtime
 Farkles do not return any value. They typically represent literal symbols
 that can only take one value. Building an untyped designtime Farkle will
 result in a syntax-checking runtime Farkle with no custom post-processor.&lt;/para&gt;&lt;para&gt;User code must not implement this interface,
 or an exception might be thrown.&lt;/para&gt;&lt;/remarks&gt;<br />&lt;seealso cref=&quot;DesigntimeFarkle{T}&quot; /&gt;</em><br /><br />--------------------<br />type DesigntimeFarkle&lt;&#39;T&gt; =
  inherit DesigntimeFarkle<br /><em>&lt;summary&gt;An object representing a grammar symbol created by Farkle.Builder.
 It corresponds to either a standalone terminal or a nonterminal
 that contains other designtime Farkles.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;Designtime Farkles cannot be used to parse text but can be
 composed into larger designtime Farkles. To actually use them, they
 have to be converted to a &lt;see cref=&quot;RuntimeFarkle{T}&quot; /&gt; which however
 is not composable. This one-way conversion is performed by the &lt;c&gt;RuntimeFarkle.build&lt;/c&gt;
 function or the &lt;c&gt;Build&lt;/c&gt; extension method.&lt;/para&gt;&lt;para&gt;This interface has no members on its own; they are
 inherited from &lt;see cref=&quot;DesigntimeFarkle&quot; /&gt;.&lt;/para&gt;&lt;para&gt;User code must not implement this interface,
 or an exception might be thrown.&lt;/para&gt;&lt;/remarks&gt;<br />&lt;typeparam name=&quot;T&quot;&gt;The type of the objects this grammar generates.&lt;/typeparam&gt;<br />&lt;seealso cref=&quot;DesigntimeFarkle&quot; /&gt;</em></div>
<div class="fsdocs-tip" id="fs10">val addLineComment: commentStart: string -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Adds a line comment to the given `DesigntimeFarkle`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs11">val addBlockComment: commentStart: string -&gt; commentEnd: string -&gt; df: &#39;a -&gt; &#39;a (requires &#39;a :&gt; DesigntimeFarkle)<br /><em>&lt;summary&gt;
 Adds a block comment to the given `DesigntimeFarkle`.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs12">Multiple items<br />module RuntimeFarkle

from Farkle<br /><em>&lt;summary&gt;
 Functions to create and use `RuntimeFarkle`s.
&lt;/summary&gt;</em><br /><br />--------------------<br />type RuntimeFarkle&lt;&#39;TResult&gt; =
  private {
            Grammar: Result&lt;Grammar,BuildError list&gt;
            PostProcessor: PostProcessor&lt;&#39;TResult&gt;
            TokenizerFactory: TokenizerFactory
          }
  interface IGrammarProvider
  member Cast: unit -&gt; RuntimeFarkle&lt;obj&gt;
  member ChangePostProcessor: pp: PostProcessor&lt;&#39;TNewResult&gt; -&gt; RuntimeFarkle&lt;&#39;TNewResult&gt;
  member ChangeTokenizer: tokenizerFactory: TokenizerFactory -&gt; RuntimeFarkle&lt;&#39;TResult&gt; + 1 overload
  member GetBuildErrorMessage: unit -&gt; string
  member GetBuildErrors: unit -&gt; BuildError list
  member GetGrammar: unit -&gt; Grammar
  member Parse: input: CharStream -&gt; Result&lt;&#39;TResult,FarkleError&gt; + 3 overloads
  member ParseFile: path: string -&gt; Result&lt;&#39;TResult,FarkleError&gt;
  member SyntaxCheck: unit -&gt; RuntimeFarkle&lt;obj&gt;
  ...<br /><em>&lt;summary&gt;A reusable parser and post-processor,
 created for a specific grammar, and returning
 a specific type of object that best describes
 an expression of the language of this grammar.&lt;/summary&gt;<br />&lt;remarks&gt;&lt;para&gt;Its parsing methods return an F# result
 type containing either the post-processed return
 type, or a type describing what did wrong and where.&lt;/para&gt;&lt;para&gt;Exceptions during post-processing (apart from
 &lt;see cref=&quot;ParserApplicationException&quot; /&gt;) are thrown
 after being wrapped in a &lt;see cref=&quot;PostProcessorException&quot; /&gt;.&lt;/para&gt;&lt;/remarks&gt;</em></div>
<div class="fsdocs-tip" id="fs13">val markForPrecompile: df: DesigntimeFarkle&lt;&#39;a&gt; -&gt; PrecompilableDesigntimeFarkle&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
 Marks the given designtime as available to have its grammar
 precompiled ahead of time. Learn more, including usage restrictions
 at https://teo-tsirpanis.github.io/Farkle/the-precompiler.html
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs14">val runtime: RuntimeFarkle&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs15">val buildPrecompiled: pcdf: PrecompilableDesigntimeFarkle&lt;&#39;a&gt; -&gt; RuntimeFarkle&lt;&#39;a&gt;<br /><em>&lt;summary&gt;
 Creates a `RuntimeFarkle` from the given typed `PrecompilableDesigntimeFarkle`.
 In case the designtime Farkle has not been precompiled, the `RuntimeFarkle` will
 fail every time it is used. The precompiler will run by installing the package
 `Farkle.Tools.MSBuild`. Learn more at https://teo-tsirpanis.github.io/Farkle/the-precompiler.html
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs16">val composable: DesigntimeFarkle&lt;int&gt;</div>
<div class="fsdocs-tip" id="fs17">property PrecompilableDesigntimeFarkle.InnerDesigntimeFarkle: DesigntimeFarkle&lt;int&gt; with get<br /><em>&lt;summary&gt;
 The typed designtime Farkle held by this object.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs18">type Dummy =
  class end</div>
<div class="fsdocs-tip" id="fs19">val designtime: DesigntimeFarkle</div>
<div class="fsdocs-tip" id="fs20">val literal: str: string -&gt; DesigntimeFarkle<br /><em>&lt;summary&gt;
 An alias for the `Terminal.Literal` function.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs21">val worksInAot: PrecompilableDesigntimeFarkle</div>
<div class="fsdocs-tip" id="fs22">static member PrecompilerExtensions.MarkForPrecompile: df: DesigntimeFarkle -&gt; PrecompilableDesigntimeFarkle<br />static member PrecompilerExtensions.MarkForPrecompile: df: DesigntimeFarkle * asm: System.Reflection.Assembly -&gt; PrecompilableDesigntimeFarkle</div>
<div class="fsdocs-tip" id="fs23">val typeof&lt;&#39;T&gt; : System.Type</div>

        </div>
    </div>

    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <script type="text/javascript">var fsdocs_search_baseurl = 'https://teo-tsirpanis.github.io/Farkle/';</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
    <script async type="text/javascript" src="https://teo-tsirpanis.github.io/Farkle/content/fsdocs-search.js"></script>
    <!-- END SEARCH BOX: this adds support for the search box -->
  </body>

</html>